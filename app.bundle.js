/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar InfiniteTree = __webpack_require__(1);\n\nvar data = [];\nvar source = '{\"id\":\"<root>\",\"label\":\"<root>\",\"children\":[{\"id\":\"alpha\",\"label\":\"Alpha\"},{\"id\":\"bravo\",\"label\":\"Bravo\",\"children\":[{\"id\":\"charlie\",\"label\":\"Charlie\",\"children\":[{\"id\":\"delta\",\"label\":\"Delta\",\"children\":[{\"id\":\"echo\",\"label\":\"Echo\"},{\"id\":\"foxtrot\",\"label\":\"Foxtrot\"}]},{\"id\":\"golf\",\"label\":\"Golf\"}]},{\"id\":\"hotel\",\"label\":\"Hotel\",\"children\":[{\"id\":\"india\",\"label\":\"India\",\"children\":[{\"id\":\"juliet\",\"label\":\"Juliet\"}]}]},{\"id\":\"kilo\",\"label\":\"Kilo\"}]}]}';\n\nfor (var i = 0; i < 1000; ++i) {\n    data.push(JSON.parse(source.replace(/\"(id|label)\":\"([^\"]*)\"/g, '\"$1\": \"$2.' + i + '\"')));\n}\n\nvar tree = new InfiniteTree({\n    el: document.querySelector('#tree'),\n    data: data,\n    autoOpen: true\n});\n\nwindow.tree = tree;\n\n// API\n// node = tree.getNodeById();\n// tree.selectNode();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/index.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports[\"InfiniteTree\"] = factory();else root[\"InfiniteTree\"] = factory();\n})(undefined, function () {\n\treturn (/******/function (modules) {\n\t\t\t// webpackBootstrap\n\t\t\t/******/ // The module cache\n\t\t\t/******/var installedModules = {};\n\n\t\t\t/******/ // The require function\n\t\t\t/******/function __webpack_require__(moduleId) {\n\n\t\t\t\t/******/ // Check if module is in cache\n\t\t\t\t/******/if (installedModules[moduleId])\n\t\t\t\t\t/******/return installedModules[moduleId].exports;\n\n\t\t\t\t/******/ // Create a new module (and put it into the cache)\n\t\t\t\t/******/var module = installedModules[moduleId] = {\n\t\t\t\t\t/******/exports: {},\n\t\t\t\t\t/******/id: moduleId,\n\t\t\t\t\t/******/loaded: false\n\t\t\t\t\t/******/ };\n\n\t\t\t\t/******/ // Execute the module function\n\t\t\t\t/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t\t\t\t/******/ // Flag the module as loaded\n\t\t\t\t/******/module.loaded = true;\n\n\t\t\t\t/******/ // Return the exports of the module\n\t\t\t\t/******/return module.exports;\n\t\t\t\t/******/\n\t\t\t}\n\n\t\t\t/******/ // expose the modules object (__webpack_modules__)\n\t\t\t/******/__webpack_require__.m = modules;\n\n\t\t\t/******/ // expose the module cache\n\t\t\t/******/__webpack_require__.c = installedModules;\n\n\t\t\t/******/ // __webpack_public_path__\n\t\t\t/******/__webpack_require__.p = \"\";\n\n\t\t\t/******/ // Load entry module and return exports\n\t\t\t/******/return __webpack_require__(0);\n\t\t\t/******/\n\t\t}(\n\t\t/************************************************************************/\n\t\t/******/[\n\t\t/* 0 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\tvar _createClass = function () {\n\t\t\t\tfunction defineProperties(target, props) {\n\t\t\t\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\t\t\t\tvar descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n\t\t\t\t\t}\n\t\t\t\t}return function (Constructor, protoProps, staticProps) {\n\t\t\t\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n\t\t\t\t};\n\t\t\t}();\n\n\t\t\tvar _events = __webpack_require__(1);\n\n\t\t\tvar _events2 = _interopRequireDefault(_events);\n\n\t\t\tvar _clusterize = __webpack_require__(2);\n\n\t\t\tvar _clusterize2 = _interopRequireDefault(_clusterize);\n\n\t\t\tvar _utils = __webpack_require__(3);\n\n\t\t\tvar _flattree = __webpack_require__(4);\n\n\t\t\tfunction _interopRequireDefault(obj) {\n\t\t\t\treturn obj && obj.__esModule ? obj : { default: obj };\n\t\t\t}\n\n\t\t\tfunction _classCallCheck(instance, Constructor) {\n\t\t\t\tif (!(instance instanceof Constructor)) {\n\t\t\t\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction _possibleConstructorReturn(self, call) {\n\t\t\t\tif (!self) {\n\t\t\t\t\tthrow new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t\t\t\t}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t\t\t}\n\n\t\t\tfunction _inherits(subClass, superClass) {\n\t\t\t\tif (typeof superClass !== \"function\" && superClass !== null) {\n\t\t\t\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));\n\t\t\t\t}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t\t\t}\n\n\t\t\tvar extend = function extend(target) {\n\t\t\t\tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\t\tsources[_key - 1] = arguments[_key];\n\t\t\t\t}\n\n\t\t\t\tsources.forEach(function (source) {\n\t\t\t\t\tfor (var key in source) {\n\t\t\t\t\t\tif (source.hasOwnProperty(key)) {\n\t\t\t\t\t\t\ttarget[key] = source[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn target;\n\t\t\t};\n\n\t\t\tvar addEventListener = function addEventListener(target, type, listener) {\n\t\t\t\tif (target.attachEvent) {\n\t\t\t\t\treturn target.attachEvent('on' + type, listener);\n\t\t\t\t} else {\n\t\t\t\t\treturn target.addEventListener(type, listener, false);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar removeEventListener = function removeEventListener(target, type, listener) {\n\t\t\t\tif (target.detachEvent) {\n\t\t\t\t\treturn target.detachEvent('on' + type, listener);\n\t\t\t\t} else {\n\t\t\t\t\treturn target.removeEventListener(type, listener, false);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar stopPropagation = function stopPropagation(evt) {\n\t\t\t\tif (typeof evt.stopPropagation !== 'undefined') {\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t} else {\n\t\t\t\t\tevt.cancelBubble = true;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar generateRowsByNodes = function generateRowsByNodes() {\n\t\t\t\tvar nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n\t\t\t\tvar rows = nodes.map(function (node) {\n\t\t\t\t\tvar id = node.id;\n\t\t\t\t\tvar label = node.label;\n\t\t\t\t\tvar state = node.state;\n\t\t\t\t\tvar depth = state.depth;\n\t\t\t\t\tvar more = state.more;\n\t\t\t\t\tvar open = state.open;\n\t\t\t\t\tvar path = state.path;\n\t\t\t\t\tvar children = state.children;\n\t\t\t\t\tvar total = state.total;\n\t\t\t\t\tvar _state$selected = state.selected;\n\t\t\t\t\tvar selected = _state$selected === undefined ? false : _state$selected;\n\n\t\t\t\t\tvar togglerContent = '';\n\t\t\t\t\tif (more && open) {\n\t\t\t\t\t\ttogglerContent = '▼';\n\t\t\t\t\t}\n\t\t\t\t\tif (more && !open) {\n\t\t\t\t\t\ttogglerContent = '►';\n\t\t\t\t\t}\n\t\t\t\t\tvar toggler = (0, _utils.buildHTML)('a', togglerContent, {\n\t\t\t\t\t\t'class': function () {\n\t\t\t\t\t\t\tif (more && open) {\n\t\t\t\t\t\t\t\treturn (0, _utils.classNames)('tree-toggler');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (more && !open) {\n\t\t\t\t\t\t\t\treturn (0, _utils.classNames)('tree-toggler', 'tree-closed');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}()\n\t\t\t\t\t});\n\t\t\t\t\tvar title = (0, _utils.buildHTML)('span', (0, _utils.quoteattr)(label), {\n\t\t\t\t\t\t'class': (0, _utils.classNames)('tree-title')\n\t\t\t\t\t});\n\t\t\t\t\tvar treeNode = (0, _utils.buildHTML)('div', toggler + title, {\n\t\t\t\t\t\t'class': 'tree-node',\n\t\t\t\t\t\t'style': 'margin-left: ' + depth * 12 + 'px'\n\t\t\t\t\t});\n\t\t\t\t\tvar treeItem = (0, _utils.buildHTML)('div', treeNode, {\n\t\t\t\t\t\t'aria-id': id,\n\t\t\t\t\t\t'aria-expanded': more && open,\n\t\t\t\t\t\t'aria-depth': depth,\n\t\t\t\t\t\t'aria-path': path,\n\t\t\t\t\t\t'aria-selected': selected,\n\t\t\t\t\t\t'aria-children': children ? Object.keys(children).length : 0,\n\t\t\t\t\t\t'aria-total': total,\n\t\t\t\t\t\t'class': (0, _utils.classNames)('tree-item', { 'tree-selected': selected })\n\t\t\t\t\t});\n\n\t\t\t\t\treturn treeItem;\n\t\t\t\t});\n\n\t\t\t\treturn rows;\n\t\t\t};\n\n\t\t\tvar InfiniteTree = function (_events$EventEmitter) {\n\t\t\t\t_inherits(InfiniteTree, _events$EventEmitter);\n\n\t\t\t\tfunction InfiniteTree() {\n\t\t\t\t\tvar options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t\t\t\t\t_classCallCheck(this, InfiniteTree);\n\n\t\t\t\t\tvar _this = _possibleConstructorReturn(this, Object.getPrototypeOf(InfiniteTree).call(this));\n\n\t\t\t\t\t_this.options = {\n\t\t\t\t\t\tel: null,\n\t\t\t\t\t\tautoOpen: false\n\t\t\t\t\t};\n\t\t\t\t\t_this.state = {\n\t\t\t\t\t\topenNodes: [],\n\t\t\t\t\t\tselectedNode: null\n\t\t\t\t\t};\n\t\t\t\t\t_this.clusterize = null;\n\t\t\t\t\t_this.nodes = [];\n\t\t\t\t\t_this.rows = [];\n\t\t\t\t\t_this.contentElement = null;\n\n\t\t\t\t\t_this.contentListener = function (evt) {\n\t\t\t\t\t\tvar target = evt.target;\n\t\t\t\t\t\tvar currentTarget = evt.currentTarget;\n\n\t\t\t\t\t\tstopPropagation(evt);\n\n\t\t\t\t\t\tif (target !== currentTarget) {\n\t\t\t\t\t\t\tvar itemTarget = target;\n\t\t\t\t\t\t\tvar itemIndex = 0;\n\n\t\t\t\t\t\t\twhile (itemTarget && itemTarget.parentElement !== currentTarget) {\n\t\t\t\t\t\t\t\titemTarget = itemTarget.parentElement;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Get item's index\n\t\t\t\t\t\t\t\tvar p = itemTarget;\n\t\t\t\t\t\t\t\twhile (p.previousSibling) {\n\t\t\t\t\t\t\t\t\tp = p.previousSibling;\n\t\t\t\t\t\t\t\t\t++itemIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar nodeIndex = itemIndex;\n\t\t\t\t\t\t\tvar node = _this.nodes[nodeIndex];\n\t\t\t\t\t\t\tvar _this$eventHandler = _this.eventHandler;\n\t\t\t\t\t\t\tvar openNode = _this$eventHandler.openNode;\n\t\t\t\t\t\t\tvar closeNode = _this$eventHandler.closeNode;\n\t\t\t\t\t\t\tvar selectNode = _this$eventHandler.selectNode;\n\n\t\t\t\t\t\t\t// Click on the toggler to open/close a tree node\n\n\t\t\t\t\t\t\tif (target.className.indexOf('tree-toggler') >= 0) {\n\t\t\t\t\t\t\t\tif (_this.state.openNodes.indexOf(node) >= 0) {\n\t\t\t\t\t\t\t\t\t// Close node\n\t\t\t\t\t\t\t\t\tcloseNode({ evt: evt, node: node, nodeIndex: nodeIndex });\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\topenNode({ evt: evt, node: node, nodeIndex: nodeIndex });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tselectNode({ evt: evt, node: node, nodeIndex: nodeIndex });\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_this.clusterize.update(_this.rows);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t_this.eventHandler = {\n\t\t\t\t\t\tcloseNode: function closeNode(_ref) {\n\t\t\t\t\t\t\tvar evt = _ref.evt;\n\t\t\t\t\t\t\tvar node = _ref.node;\n\t\t\t\t\t\t\tvar nodeIndex = _ref.nodeIndex;\n\n\t\t\t\t\t\t\t// Keep selected node unchanged if \"node\" is equal to \"this.state.selectedNode\"\n\t\t\t\t\t\t\tif (_this.state.selectedNode && _this.state.selectedNode !== node) {\n\t\t\t\t\t\t\t\tvar selectNode = _this.eventHandler.selectNode;\n\n\t\t\t\t\t\t\t\t// Action:\n\t\t\t\t\t\t\t\t//   close \"node.0.0\"\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Tree:\n\t\t\t\t\t\t\t\t// [0] - node.0\n\t\t\t\t\t\t\t\t// [1]  - node.0.0      => next selected node (index=1, total=2)\n\t\t\t\t\t\t\t\t// [2]      node.0.0.0  => last selected node (index=2, total=0)\n\t\t\t\t\t\t\t\t// [3]      node.0.0.1\n\t\t\t\t\t\t\t\t// [4]    node.0.1\n\n\t\t\t\t\t\t\t\tvar selectedIndex = _this.nodes.indexOf(_this.state.selectedNode);\n\t\t\t\t\t\t\t\tvar rangeFrom = nodeIndex + 1;\n\t\t\t\t\t\t\t\tvar rangeTo = nodeIndex + node.state.total;\n\n\t\t\t\t\t\t\t\tif (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n\t\t\t\t\t\t\t\t\tselectNode({ evt: evt, node: node, nodeIndex: nodeIndex });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnode.state.open = false; // Set node.state.open to false\n\t\t\t\t\t\t\tvar openNodes = _this.state.openNodes.filter(function (node) {\n\t\t\t\t\t\t\t\treturn node.state.more && node.state.open;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t_this.state.openNodes = openNodes;\n\n\t\t\t\t\t\t\tvar deleteCount = node.state.total;\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Traversing up through ancestors to subtract node.state.total\n\t\t\t\t\t\t\t\tvar p = node;\n\t\t\t\t\t\t\t\twhile (p) {\n\t\t\t\t\t\t\t\t\tp.state.total = p.state.total - deleteCount;\n\t\t\t\t\t\t\t\t\tp = p.parent;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Remove elements from an array\n\t\t\t\t\t\t\t_this.nodes.splice(nodeIndex + 1, deleteCount);\n\t\t\t\t\t\t\t_this.rows.splice(nodeIndex + 1, deleteCount);\n\t\t\t\t\t\t\t_this.rows[nodeIndex] = generateRowsByNodes([node])[0];\n\t\t\t\t\t\t\t_this.emit('tree.close', node);\n\t\t\t\t\t\t},\n\t\t\t\t\t\topenNode: function openNode(_ref2) {\n\t\t\t\t\t\t\tvar evt = _ref2.evt;\n\t\t\t\t\t\t\tvar node = _ref2.node;\n\t\t\t\t\t\t\tvar nodeIndex = _ref2.nodeIndex;\n\n\t\t\t\t\t\t\tnode.state.open = true; // Set node.state.open to true\n\t\t\t\t\t\t\tvar openNodes = [node].concat(_this.state.openNodes); // the most recently used items first\n\t\t\t\t\t\t\t_this.state.openNodes = openNodes;\n\n\t\t\t\t\t\t\tvar nodes = (0, _flattree.flatten)(node.children, { openNodes: _this.state.openNodes });\n\t\t\t\t\t\t\tvar rows = generateRowsByNodes(nodes);\n\n\t\t\t\t\t\t\t// Insert an array inside another array\n\t\t\t\t\t\t\t_this.nodes.splice.apply(_this.nodes, [nodeIndex + 1, 0].concat(nodes));\n\t\t\t\t\t\t\t_this.rows.splice.apply(_this.rows, [nodeIndex + 1, 0].concat(rows));\n\t\t\t\t\t\t\t_this.rows[nodeIndex] = generateRowsByNodes([node])[0];\n\t\t\t\t\t\t\t_this.emit('tree.open', node);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tselectNode: function selectNode(_ref3) {\n\t\t\t\t\t\t\tvar evt = _ref3.evt;\n\t\t\t\t\t\t\tvar node = _ref3.node;\n\t\t\t\t\t\t\tvar nodeIndex = _ref3.nodeIndex;\n\n\t\t\t\t\t\t\t// select node\n\t\t\t\t\t\t\tif (_this.state.selectedNode !== node) {\n\t\t\t\t\t\t\t\tnode.state.selected = true;\n\t\t\t\t\t\t\t\t_this.rows[nodeIndex] = generateRowsByNodes([node])[0];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// deselect node\n\t\t\t\t\t\t\tif (_this.state.selectedNode) {\n\t\t\t\t\t\t\t\tvar selectedNode = _this.state.selectedNode;\n\t\t\t\t\t\t\t\tvar selectedIndex = _this.nodes.indexOf(selectedNode);\n\t\t\t\t\t\t\t\tselectedNode.state.selected = false;\n\t\t\t\t\t\t\t\t_this.rows[selectedIndex] = generateRowsByNodes([selectedNode])[0];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (_this.state.selectedNode !== node) {\n\t\t\t\t\t\t\t\t_this.state.selectedNode = node;\n\t\t\t\t\t\t\t\t_this.emit('tree.select', node);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_this.state.selectedNode = null;\n\t\t\t\t\t\t\t\t_this.emit('tree.select', null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tvar _options$autoOpen = options.autoOpen;\n\t\t\t\t\tvar autoOpen = _options$autoOpen === undefined ? false : _options$autoOpen;\n\t\t\t\t\tvar _options$el = options.el;\n\t\t\t\t\tvar el = _options$el === undefined ? null : _options$el;\n\t\t\t\t\tvar _options$data = options.data;\n\t\t\t\t\tvar data = _options$data === undefined ? null : _options$data;\n\n\t\t\t\t\tif (!el) {\n\t\t\t\t\t\tconsole.error('Failed to initialize infinite tree: el is not specified.');\n\t\t\t\t\t\treturn _possibleConstructorReturn(_this);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Assign options\n\t\t\t\t\t_this.options = extend({}, { autoOpen: autoOpen, el: el });\n\n\t\t\t\t\t_this.create();\n\n\t\t\t\t\t// Load tree data if it's provided\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\t_this.loadData(data);\n\t\t\t\t\t}\n\t\t\t\t\treturn _this;\n\t\t\t\t}\n\n\t\t\t\t_createClass(InfiniteTree, [{\n\t\t\t\t\tkey: 'create',\n\t\t\t\t\tvalue: function create() {\n\t\t\t\t\t\tvar infiniteTree = document.createElement('div');\n\t\t\t\t\t\tinfiniteTree.className = (0, _utils.classNames)('infinite-tree');\n\t\t\t\t\t\tvar infiniteTreeScroll = document.createElement('div');\n\t\t\t\t\t\tinfiniteTreeScroll.className = (0, _utils.classNames)('infinite-tree-scroll');\n\t\t\t\t\t\tvar infiniteTreeContent = document.createElement('div');\n\t\t\t\t\t\tinfiniteTreeContent.className = (0, _utils.classNames)('infinite-tree-content');\n\n\t\t\t\t\t\tinfiniteTreeScroll.appendChild(infiniteTreeContent);\n\t\t\t\t\t\tinfiniteTree.appendChild(infiniteTreeScroll);\n\t\t\t\t\t\tthis.options.el.appendChild(infiniteTree);\n\n\t\t\t\t\t\tthis.clusterize = new _clusterize2.default({\n\t\t\t\t\t\t\ttag: 'div',\n\t\t\t\t\t\t\trows: [],\n\t\t\t\t\t\t\tscrollElem: infiniteTreeScroll,\n\t\t\t\t\t\t\tcontentElem: infiniteTreeContent,\n\t\t\t\t\t\t\tno_data_class: 'infinite-tree-no-data'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis.contentElement = infiniteTreeContent;\n\t\t\t\t\t\taddEventListener(this.contentElement, 'click', this.contentListener);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'destroy',\n\t\t\t\t\tvalue: function destroy() {\n\t\t\t\t\t\tremoveEventListener(this.contentElement, 'click', this.contentListener);\n\n\t\t\t\t\t\tif (this.clusterize) {\n\t\t\t\t\t\t\tthis.clusterize.clear();\n\t\t\t\t\t\t\tthis.clusterize = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.nodes = [];\n\t\t\t\t\t\tthis.rows = [];\n\t\t\t\t\t\tthis.state.openNodes = [];\n\t\t\t\t\t\tthis.state.selectedNode = null;\n\n\t\t\t\t\t\t// Remove all child nodes\n\t\t\t\t\t\twhile (this.contentElement.firstChild) {\n\t\t\t\t\t\t\tthis.contentElement.removeChild(this.contentElement.firstChild);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'clear',\n\t\t\t\t\tvalue: function clear() {\n\t\t\t\t\t\tthis.clusterize.clear();\n\t\t\t\t\t\tthis.nodes = [];\n\t\t\t\t\t\tthis.rows = [];\n\t\t\t\t\t\tthis.state.openNodes = [];\n\t\t\t\t\t\tthis.state.selectedNode = null;\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'handleCloseNode',\n\t\t\t\t\tvalue: function handleCloseNode(_ref4) {\n\t\t\t\t\t\tvar evt = _ref4.evt;\n\t\t\t\t\t\tvar node = _ref4.node;\n\t\t\t\t\t\tvar nodeIndex = _ref4.nodeIndex;\n\n\t\t\t\t\t\t// Keep selected node unchanged if \"node\" is equal to \"this.state.selectedNode\"\n\t\t\t\t\t\tif (this.state.selectedNode && this.state.selectedNode !== node) {\n\t\t\t\t\t\t\t// Action:\n\t\t\t\t\t\t\t//   close \"node.0.0\"\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Tree:\n\t\t\t\t\t\t\t// [0] - node.0\n\t\t\t\t\t\t\t// [1]  - node.0.0      => next selected node (index=1, total=2)\n\t\t\t\t\t\t\t// [2]      node.0.0.0  => last selected node (index=2, total=0)\n\t\t\t\t\t\t\t// [3]      node.0.0.1\n\t\t\t\t\t\t\t// [4]    node.0.1\n\t\t\t\t\t\t\tvar selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n\t\t\t\t\t\t\tvar rangeFrom = nodeIndex + 1;\n\t\t\t\t\t\t\tvar rangeTo = nodeIndex + node.state.total;\n\n\t\t\t\t\t\t\tif (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n\t\t\t\t\t\t\t\tthis.eventHandler.selectNode({ evt: evt, node: node, nodeIndex: nodeIndex });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode.state.open = false; // Set node.state.open to false\n\t\t\t\t\t\tvar openNodes = this.state.openNodes.filter(function (node) {\n\t\t\t\t\t\t\treturn node.state.more && node.state.open;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis.state.openNodes = openNodes;\n\n\t\t\t\t\t\tvar deleteCount = node.state.total;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Traversing up through ancestors to subtract node.state.total\n\t\t\t\t\t\t\tvar p = node;\n\t\t\t\t\t\t\twhile (p) {\n\t\t\t\t\t\t\t\tp.state.total = p.state.total - deleteCount;\n\t\t\t\t\t\t\t\tp = p.parent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove elements from an array\n\t\t\t\t\t\tthis.nodes.splice(nodeIndex + 1, deleteCount);\n\t\t\t\t\t\tthis.rows.splice(nodeIndex + 1, deleteCount);\n\t\t\t\t\t\tthis.rows[nodeIndex] = generateRowsByNodes([node])[0];\n\t\t\t\t\t\tthis.emit('tree.close', node);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'handleOpenNode',\n\t\t\t\t\tvalue: function handleOpenNode(_ref5) {\n\t\t\t\t\t\tvar evt = _ref5.evt;\n\t\t\t\t\t\tvar node = _ref5.node;\n\t\t\t\t\t\tvar nodeIndex = _ref5.nodeIndex;\n\n\t\t\t\t\t\tnode.state.open = true; // Set node.state.open to true\n\t\t\t\t\t\tvar openNodes = [node].concat(this.state.openNodes); // the most recently used items first\n\t\t\t\t\t\tthis.state.openNodes = openNodes;\n\n\t\t\t\t\t\tvar nodes = (0, _flattree.flatten)(node.children, { openNodes: this.state.openNodes });\n\t\t\t\t\t\tvar rows = generateRowsByNodes(nodes);\n\n\t\t\t\t\t\t// Insert an array inside another array\n\t\t\t\t\t\tthis.nodes.splice.apply(this.nodes, [nodeIndex + 1, 0].concat(nodes));\n\t\t\t\t\t\tthis.rows.splice.apply(this.rows, [nodeIndex + 1, 0].concat(rows));\n\t\t\t\t\t\tthis.rows[nodeIndex] = generateRowsByNodes([node])[0];\n\t\t\t\t\t\tthis.emit('tree.open', node);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'handleSelectNode',\n\t\t\t\t\tvalue: function handleSelectNode(_ref6) {\n\t\t\t\t\t\tvar evt = _ref6.evt;\n\t\t\t\t\t\tvar node = _ref6.node;\n\t\t\t\t\t\tvar nodeIndex = _ref6.nodeIndex;\n\n\t\t\t\t\t\t// select node\n\t\t\t\t\t\tif (this.state.selectedNode !== node) {\n\t\t\t\t\t\t\tnode.state.selected = true;\n\t\t\t\t\t\t\tthis.rows[nodeIndex] = generateRowsByNodes([node])[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// deselect node\n\t\t\t\t\t\tif (this.state.selectedNode) {\n\t\t\t\t\t\t\tvar selectedNode = this.state.selectedNode;\n\t\t\t\t\t\t\tvar selectedIndex = this.nodes.indexOf(selectedNode);\n\t\t\t\t\t\t\tselectedNode.state.selected = false;\n\t\t\t\t\t\t\tthis.rows[selectedIndex] = generateRowsByNodes([selectedNode])[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.state.selectedNode !== node) {\n\t\t\t\t\t\t\tthis.state.selectedNode = node;\n\t\t\t\t\t\t\tthis.emit('tree.select', node);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.state.selectedNode = null;\n\t\t\t\t\t\t\tthis.emit('tree.select', null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add a new node after this existing node.\n\t\t\t\t\t// @param {object} newNode\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'addNodeAfter',\n\t\t\t\t\tvalue: function addNodeAfter(newNode, node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Add a new node before this existing node.\n\t\t\t\t\t// @param {object} newNode\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'addNodeBefore',\n\t\t\t\t\tvalue: function addNodeBefore(newNode, node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Add a new node as parent of this existing node.\n\t\t\t\t\t// @param {object} newNode\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'addParentNode',\n\t\t\t\t\tvalue: function addParentNode(newNode, node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Add a node to this parent node. If parentNode is empty, then the new node becomes a root node.\n\t\t\t\t\t// @param {object} newNode The new node\n\t\t\t\t\t// @param {object} parentNode The parent node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'appendNode',\n\t\t\t\t\tvalue: function appendNode(newNode, parentNode) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Close this node. The node must have child nodes.\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'closeNode',\n\t\t\t\t\tvalue: function closeNode(node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Get a tree node by the unique node id. This assumes that you have given the nodes in the data a unique id.\n\t\t\t\t\t// @param {string|number} id The unique node id\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'getNodeById',\n\t\t\t\t\tvalue: function getNodeById(id) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Get the selected node. Returns the row data or null.\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'getSelectedNode',\n\t\t\t\t\tvalue: function getSelectedNode() {\n\t\t\t\t\t\treturn this.state.selectedNode;\n\t\t\t\t\t}\n\t\t\t\t\t// Get the state of the tree.\n\t\t\t\t\t// @return {object} Returns an object that contains the ids of open nodes and selected nodes\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'getState',\n\t\t\t\t\tvalue: function getState() {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Get the root node of the tree.\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'getTree',\n\t\t\t\t\tvalue: function getTree() {\n\t\t\t\t\t\tvar tree = this.nodes.length > 0 ? this.nodes[0] : null;\n\t\t\t\t\t\twhile (tree && tree.parent !== null) {\n\t\t\t\t\t\t\ttree = tree.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tree;\n\t\t\t\t\t}\n\t\t\t\t\t// Load data in the tree.\n\t\t\t\t\t// @param {object|array} data The data is a node object or array of nodes\n\t\t\t\t\t// @param {object} [options] The options object\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'loadData',\n\t\t\t\t\tvalue: function loadData() {\n\t\t\t\t\t\tvar data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\t\t\t\t\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t\t\t\t\tvar _options$autoOpen2 = options.autoOpen;\n\t\t\t\t\t\tvar autoOpen = _options$autoOpen2 === undefined ? this.options.autoOpen : _options$autoOpen2;\n\n\t\t\t\t\t\tthis.nodes = (0, _flattree.flatten)(data, { openAllNodes: autoOpen });\n\n\t\t\t\t\t\tvar openNodes = this.nodes.filter(function (node) {\n\t\t\t\t\t\t\treturn node.state.more && node.state.open;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis.state.openNodes = openNodes;\n\t\t\t\t\t\tthis.state.selectedNode = null;\n\n\t\t\t\t\t\tthis.rows = generateRowsByNodes(this.nodes);\n\t\t\t\t\t\tthis.clusterize.update(this.rows);\n\t\t\t\t\t}\n\t\t\t\t\t// Open this node. The node must have child nodes.\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'openNode',\n\t\t\t\t\tvalue: function openNode(node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Remove node from the tree\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'removeNode',\n\t\t\t\t\tvalue: function removeNode(node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Scroll to this node.\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'scrollToNode',\n\t\t\t\t\tvalue: function scrollToNode(node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Select this node. You can deselect the current node by calling selectNode(null).\n\t\t\t\t\t// @param {object} node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'selectNode',\n\t\t\t\t\tvalue: function selectNode(node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Set the state of the tree. See getState for more information.\n\t\t\t\t\t// @param {object} state The state object\n\t\t\t\t\t// @param {string} [state.openNodes] The ids of open nodes\n\t\t\t\t\t// @param {string} [state.selectedNode] The id of selected node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'setState',\n\t\t\t\t\tvalue: function setState() {\n\t\t\t\t\t\tvar state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t\t\t\t}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Open or close this node.\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'toggle',\n\t\t\t\t\tvalue: function toggle(node) {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Get the tree data as string.\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'toString',\n\t\t\t\t\tvalue: function toString() {}\n\t\t\t\t\t// TODO\n\n\t\t\t\t\t// Update the title of a node. You can also update the data.\n\t\t\t\t\t// @param {object} node\n\t\t\t\t\t// @param {object} data The data object\n\t\t\t\t\t// @param {object} [data.label] The title of a node\n\n\t\t\t\t}, {\n\t\t\t\t\tkey: 'updateNode',\n\t\t\t\t\tvalue: function updateNode(node, data) {\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t}\n\t\t\t\t}]);\n\n\t\t\t\treturn InfiniteTree;\n\t\t\t}(_events2.default.EventEmitter);\n\n\t\t\tmodule.exports = InfiniteTree;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 1 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// Copyright Joyent, Inc. and other Node contributors.\n\t\t\t//\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t\t\t// copy of this software and associated documentation files (the\n\t\t\t// \"Software\"), to deal in the Software without restriction, including\n\t\t\t// without limitation the rights to use, copy, modify, merge, publish,\n\t\t\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t\t\t// persons to whom the Software is furnished to do so, subject to the\n\t\t\t// following conditions:\n\t\t\t//\n\t\t\t// The above copyright notice and this permission notice shall be included\n\t\t\t// in all copies or substantial portions of the Software.\n\t\t\t//\n\t\t\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t\t\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t\t\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t\t\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t\t\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t\t\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t\t\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\t\t\tfunction EventEmitter() {\n\t\t\t\tthis._events = this._events || {};\n\t\t\t\tthis._maxListeners = this._maxListeners || undefined;\n\t\t\t}\n\t\t\tmodule.exports = EventEmitter;\n\n\t\t\t// Backwards-compat with node 0.10.x\n\t\t\tEventEmitter.EventEmitter = EventEmitter;\n\n\t\t\tEventEmitter.prototype._events = undefined;\n\t\t\tEventEmitter.prototype._maxListeners = undefined;\n\n\t\t\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t\t\t// added to it. This is a useful default which helps finding memory leaks.\n\t\t\tEventEmitter.defaultMaxListeners = 10;\n\n\t\t\t// Obviously not all Emitters should be limited to 10. This function allows\n\t\t\t// that to be increased. Set to zero for unlimited.\n\t\t\tEventEmitter.prototype.setMaxListeners = function (n) {\n\t\t\t\tif (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n\t\t\t\tthis._maxListeners = n;\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tEventEmitter.prototype.emit = function (type) {\n\t\t\t\tvar er, handler, len, args, i, listeners;\n\n\t\t\t\tif (!this._events) this._events = {};\n\n\t\t\t\t// If there is no 'error' event listener then throw.\n\t\t\t\tif (type === 'error') {\n\t\t\t\t\tif (!this._events.error || isObject(this._events.error) && !this._events.error.length) {\n\t\t\t\t\t\ter = arguments[1];\n\t\t\t\t\t\tif (er instanceof Error) {\n\t\t\t\t\t\t\tthrow er; // Unhandled 'error' event\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow TypeError('Uncaught, unspecified \"error\" event.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thandler = this._events[type];\n\n\t\t\t\tif (isUndefined(handler)) return false;\n\n\t\t\t\tif (isFunction(handler)) {\n\t\t\t\t\tswitch (arguments.length) {\n\t\t\t\t\t\t// fast cases\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\thandler.call(this);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\thandler.call(this, arguments[1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\thandler.call(this, arguments[1], arguments[2]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// slower\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t\t\t\t\thandler.apply(this, args);\n\t\t\t\t\t}\n\t\t\t\t} else if (isObject(handler)) {\n\t\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t\t\tlisteners = handler.slice();\n\t\t\t\t\tlen = listeners.length;\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tlisteners[i].apply(this, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tEventEmitter.prototype.addListener = function (type, listener) {\n\t\t\t\tvar m;\n\n\t\t\t\tif (!isFunction(listener)) throw TypeError('listener must be a function');\n\n\t\t\t\tif (!this._events) this._events = {};\n\n\t\t\t\t// To avoid recursion in the case that type === \"newListener\"! Before\n\t\t\t\t// adding it to the listeners, first emit \"newListener\".\n\t\t\t\tif (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);\n\n\t\t\t\tif (!this._events[type])\n\t\t\t\t\t// Optimize the case of one listener. Don't need the extra array object.\n\t\t\t\t\tthis._events[type] = listener;else if (isObject(this._events[type]))\n\t\t\t\t\t// If we've already got an array, just append.\n\t\t\t\t\tthis._events[type].push(listener);else\n\t\t\t\t\t// Adding the second element, need to change to array.\n\t\t\t\t\tthis._events[type] = [this._events[type], listener];\n\n\t\t\t\t// Check for listener leak\n\t\t\t\tif (isObject(this._events[type]) && !this._events[type].warned) {\n\t\t\t\t\tif (!isUndefined(this._maxListeners)) {\n\t\t\t\t\t\tm = this._maxListeners;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tm = EventEmitter.defaultMaxListeners;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m && m > 0 && this._events[type].length > m) {\n\t\t\t\t\t\tthis._events[type].warned = true;\n\t\t\t\t\t\tconsole.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n\t\t\t\t\t\tif (typeof console.trace === 'function') {\n\t\t\t\t\t\t\t// not supported in IE 10\n\t\t\t\t\t\t\tconsole.trace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n\t\t\tEventEmitter.prototype.once = function (type, listener) {\n\t\t\t\tif (!isFunction(listener)) throw TypeError('listener must be a function');\n\n\t\t\t\tvar fired = false;\n\n\t\t\t\tfunction g() {\n\t\t\t\t\tthis.removeListener(type, g);\n\n\t\t\t\t\tif (!fired) {\n\t\t\t\t\t\tfired = true;\n\t\t\t\t\t\tlistener.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tg.listener = listener;\n\t\t\t\tthis.on(type, g);\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// emits a 'removeListener' event iff the listener was removed\n\t\t\tEventEmitter.prototype.removeListener = function (type, listener) {\n\t\t\t\tvar list, position, length, i;\n\n\t\t\t\tif (!isFunction(listener)) throw TypeError('listener must be a function');\n\n\t\t\t\tif (!this._events || !this._events[type]) return this;\n\n\t\t\t\tlist = this._events[type];\n\t\t\t\tlength = list.length;\n\t\t\t\tposition = -1;\n\n\t\t\t\tif (list === listener || isFunction(list.listener) && list.listener === listener) {\n\t\t\t\t\tdelete this._events[type];\n\t\t\t\t\tif (this._events.removeListener) this.emit('removeListener', type, listener);\n\t\t\t\t} else if (isObject(list)) {\n\t\t\t\t\tfor (i = length; i-- > 0;) {\n\t\t\t\t\t\tif (list[i] === listener || list[i].listener && list[i].listener === listener) {\n\t\t\t\t\t\t\tposition = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (position < 0) return this;\n\n\t\t\t\t\tif (list.length === 1) {\n\t\t\t\t\t\tlist.length = 0;\n\t\t\t\t\t\tdelete this._events[type];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist.splice(position, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._events.removeListener) this.emit('removeListener', type, listener);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tEventEmitter.prototype.removeAllListeners = function (type) {\n\t\t\t\tvar key, listeners;\n\n\t\t\t\tif (!this._events) return this;\n\n\t\t\t\t// not listening for removeListener, no need to emit\n\t\t\t\tif (!this._events.removeListener) {\n\t\t\t\t\tif (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// emit removeListener for all listeners on all events\n\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\tfor (key in this._events) {\n\t\t\t\t\t\tif (key === 'removeListener') continue;\n\t\t\t\t\t\tthis.removeAllListeners(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis.removeAllListeners('removeListener');\n\t\t\t\t\tthis._events = {};\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tlisteners = this._events[type];\n\n\t\t\t\tif (isFunction(listeners)) {\n\t\t\t\t\tthis.removeListener(type, listeners);\n\t\t\t\t} else if (listeners) {\n\t\t\t\t\t// LIFO order\n\t\t\t\t\twhile (listeners.length) {\n\t\t\t\t\t\tthis.removeListener(type, listeners[listeners.length - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete this._events[type];\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tEventEmitter.prototype.listeners = function (type) {\n\t\t\t\tvar ret;\n\t\t\t\tif (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tEventEmitter.prototype.listenerCount = function (type) {\n\t\t\t\tif (this._events) {\n\t\t\t\t\tvar evlistener = this._events[type];\n\n\t\t\t\t\tif (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\n\t\t\tEventEmitter.listenerCount = function (emitter, type) {\n\t\t\t\treturn emitter.listenerCount(type);\n\t\t\t};\n\n\t\t\tfunction isFunction(arg) {\n\t\t\t\treturn typeof arg === 'function';\n\t\t\t}\n\n\t\t\tfunction isNumber(arg) {\n\t\t\t\treturn typeof arg === 'number';\n\t\t\t}\n\n\t\t\tfunction isObject(arg) {\n\t\t\t\treturn (typeof arg === 'undefined' ? 'undefined' : _typeof2(arg)) === 'object' && arg !== null;\n\t\t\t}\n\n\t\t\tfunction isUndefined(arg) {\n\t\t\t\treturn arg === void 0;\n\t\t\t}\n\n\t\t\t/***/\n\t\t},\n\t\t/* 2 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t/*! Clusterize.js - v0.16.0 - 2016-03-12\r\n   * http://NeXTs.github.com/Clusterize.js/\r\n   * Copyright (c) 2015 Denis Lukov; Licensed GPLv3 */\n\n\t\t\t;(function (name, definition) {\n\t\t\t\tif (true) module.exports = definition();else if (typeof define == 'function' && _typeof2(define.amd) == 'object') define(definition);else this[name] = definition();\n\t\t\t})('Clusterize', function () {\n\t\t\t\t\"use strict\";\n\n\t\t\t\t// detect ie9 and lower\n\t\t\t\t// https://gist.github.com/padolsey/527683#comment-786682\n\n\t\t\t\tvar ie = function () {\n\t\t\t\t\tfor (var v = 3, el = document.createElement('b'), all = el.all || []; el.innerHTML = '<!--[if gt IE ' + ++v + ']><i><![endif]-->', all[0];) {}\n\t\t\t\t\treturn v > 4 ? v : document.documentMode;\n\t\t\t\t}(),\n\t\t\t\t    is_mac = navigator.platform.toLowerCase().indexOf('mac') + 1;\n\t\t\t\tvar Clusterize = function Clusterize(data) {\n\t\t\t\t\tif (!(this instanceof Clusterize)) return new Clusterize(data);\n\t\t\t\t\tvar self = this;\n\n\t\t\t\t\tvar defaults = {\n\t\t\t\t\t\titem_height: 0,\n\t\t\t\t\t\tblock_height: 0,\n\t\t\t\t\t\trows_in_block: 50,\n\t\t\t\t\t\trows_in_cluster: 0,\n\t\t\t\t\t\tcluster_height: 0,\n\t\t\t\t\t\tblocks_in_cluster: 4,\n\t\t\t\t\t\ttag: null,\n\t\t\t\t\t\tcontent_tag: null,\n\t\t\t\t\t\tshow_no_data_row: true,\n\t\t\t\t\t\tno_data_class: 'clusterize-no-data',\n\t\t\t\t\t\tno_data_text: 'No data',\n\t\t\t\t\t\tkeep_parity: true,\n\t\t\t\t\t\tcallbacks: {},\n\t\t\t\t\t\tscroll_top: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// public parameters\n\t\t\t\t\tself.options = {};\n\t\t\t\t\tvar options = ['rows_in_block', 'blocks_in_cluster', 'show_no_data_row', 'no_data_class', 'no_data_text', 'keep_parity', 'tag', 'callbacks'];\n\t\t\t\t\tfor (var i = 0, option; option = options[i]; i++) {\n\t\t\t\t\t\tself.options[option] = typeof data[option] != 'undefined' && data[option] != null ? data[option] : defaults[option];\n\t\t\t\t\t}\n\n\t\t\t\t\tvar elems = ['scroll', 'content'];\n\t\t\t\t\tfor (var i = 0, elem; elem = elems[i]; i++) {\n\t\t\t\t\t\tself[elem + '_elem'] = data[elem + 'Id'] ? document.getElementById(data[elem + 'Id']) : data[elem + 'Elem'];\n\t\t\t\t\t\tif (!self[elem + '_elem']) throw new Error(\"Error! Could not find \" + elem + \" element\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// tabindex forces the browser to keep focus on the scrolling list, fixes #11\n\t\t\t\t\tif (!self.content_elem.hasAttribute('tabindex')) self.content_elem.setAttribute('tabindex', 0);\n\n\t\t\t\t\t// private parameters\n\t\t\t\t\tvar rows = isArray(data.rows) ? data.rows : self.fetchMarkup(),\n\t\t\t\t\t    cache = { data: '', bottom: 0 },\n\t\t\t\t\t    scroll_top = self.scroll_elem.scrollTop;\n\n\t\t\t\t\t// get row height\n\t\t\t\t\tself.exploreEnvironment(rows);\n\n\t\t\t\t\t// append initial data\n\t\t\t\t\tself.insertToDOM(rows, cache);\n\n\t\t\t\t\t// restore the scroll position\n\t\t\t\t\tself.scroll_elem.scrollTop = scroll_top;\n\n\t\t\t\t\t// adding scroll handler\n\t\t\t\t\tvar last_cluster = false,\n\t\t\t\t\t    scroll_debounce = 0,\n\t\t\t\t\t    pointer_events_set = false,\n\t\t\t\t\t    scrollEv = function scrollEv() {\n\t\t\t\t\t\t// fixes scrolling issue on Mac #3\n\t\t\t\t\t\tif (is_mac) {\n\t\t\t\t\t\t\tif (!pointer_events_set) self.content_elem.style.pointerEvents = 'none';\n\t\t\t\t\t\t\tpointer_events_set = true;\n\t\t\t\t\t\t\tclearTimeout(scroll_debounce);\n\t\t\t\t\t\t\tscroll_debounce = setTimeout(function () {\n\t\t\t\t\t\t\t\tself.content_elem.style.pointerEvents = 'auto';\n\t\t\t\t\t\t\t\tpointer_events_set = false;\n\t\t\t\t\t\t\t}, 50);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (last_cluster != (last_cluster = self.getClusterNum())) self.insertToDOM(rows, cache);\n\t\t\t\t\t\tif (self.options.callbacks.scrollingProgress) self.options.callbacks.scrollingProgress(self.getScrollProgress());\n\t\t\t\t\t},\n\t\t\t\t\t    resize_debounce = 0,\n\t\t\t\t\t    resizeEv = function resizeEv() {\n\t\t\t\t\t\tclearTimeout(resize_debounce);\n\t\t\t\t\t\tresize_debounce = setTimeout(self.refresh, 100);\n\t\t\t\t\t};\n\t\t\t\t\ton('scroll', self.scroll_elem, scrollEv);\n\t\t\t\t\ton('resize', window, resizeEv);\n\n\t\t\t\t\t// public methods\n\t\t\t\t\tself.destroy = function (clean) {\n\t\t\t\t\t\toff('scroll', self.scroll_elem, scrollEv);\n\t\t\t\t\t\toff('resize', window, resizeEv);\n\t\t\t\t\t\tself.html((clean ? self.generateEmptyRow() : rows).join(''));\n\t\t\t\t\t};\n\t\t\t\t\tself.refresh = function () {\n\t\t\t\t\t\tself.getRowsHeight(rows) && self.update(rows);\n\t\t\t\t\t};\n\t\t\t\t\tself.update = function (new_rows) {\n\t\t\t\t\t\trows = isArray(new_rows) ? new_rows : [];\n\t\t\t\t\t\tvar scroll_top = self.scroll_elem.scrollTop;\n\t\t\t\t\t\t// fixes #39\n\t\t\t\t\t\tif (rows.length * self.options.item_height < scroll_top) {\n\t\t\t\t\t\t\tself.scroll_elem.scrollTop = 0;\n\t\t\t\t\t\t\tlast_cluster = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.insertToDOM(rows, cache);\n\t\t\t\t\t\tself.scroll_elem.scrollTop = scroll_top;\n\t\t\t\t\t};\n\t\t\t\t\tself.clear = function () {\n\t\t\t\t\t\tself.update([]);\n\t\t\t\t\t};\n\t\t\t\t\tself.getRowsAmount = function () {\n\t\t\t\t\t\treturn rows.length;\n\t\t\t\t\t};\n\t\t\t\t\tself.getScrollProgress = function () {\n\t\t\t\t\t\treturn this.options.scroll_top / (rows.length * this.options.item_height) * 100 || 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tvar add = function add(where, _new_rows) {\n\t\t\t\t\t\tvar new_rows = isArray(_new_rows) ? _new_rows : [];\n\t\t\t\t\t\tif (!new_rows.length) return;\n\t\t\t\t\t\trows = where == 'append' ? rows.concat(new_rows) : new_rows.concat(rows);\n\t\t\t\t\t\tself.insertToDOM(rows, cache);\n\t\t\t\t\t};\n\t\t\t\t\tself.append = function (rows) {\n\t\t\t\t\t\tadd('append', rows);\n\t\t\t\t\t};\n\t\t\t\t\tself.prepend = function (rows) {\n\t\t\t\t\t\tadd('prepend', rows);\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\tClusterize.prototype = {\n\t\t\t\t\tconstructor: Clusterize,\n\t\t\t\t\t// fetch existing markup\n\t\t\t\t\tfetchMarkup: function fetchMarkup() {\n\t\t\t\t\t\tvar rows = [],\n\t\t\t\t\t\t    rows_nodes = this.getChildNodes(this.content_elem);\n\t\t\t\t\t\twhile (rows_nodes.length) {\n\t\t\t\t\t\t\trows.push(rows_nodes.shift().outerHTML);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn rows;\n\t\t\t\t\t},\n\t\t\t\t\t// get tag name, content tag name, tag height, calc cluster height\n\t\t\t\t\texploreEnvironment: function exploreEnvironment(rows) {\n\t\t\t\t\t\tvar opts = this.options;\n\t\t\t\t\t\topts.content_tag = this.content_elem.tagName.toLowerCase();\n\t\t\t\t\t\tif (!rows.length) return;\n\t\t\t\t\t\tif (ie && ie <= 9 && !opts.tag) opts.tag = rows[0].match(/<([^>\\s/]*)/)[1].toLowerCase();\n\t\t\t\t\t\tif (this.content_elem.children.length <= 1) this.html(rows[0] + rows[0] + rows[0]);\n\t\t\t\t\t\tif (!opts.tag) opts.tag = this.content_elem.children[0].tagName.toLowerCase();\n\t\t\t\t\t\tthis.getRowsHeight(rows);\n\t\t\t\t\t},\n\t\t\t\t\tgetRowsHeight: function getRowsHeight(rows) {\n\t\t\t\t\t\tvar opts = this.options,\n\t\t\t\t\t\t    prev_item_height = opts.item_height;\n\t\t\t\t\t\topts.cluster_height = 0;\n\t\t\t\t\t\tif (!rows.length) return;\n\t\t\t\t\t\tvar nodes = this.content_elem.children;\n\t\t\t\t\t\topts.item_height = nodes[Math.floor(nodes.length / 2)].offsetHeight;\n\t\t\t\t\t\t// consider table's border-spacing\n\t\t\t\t\t\tif (opts.tag == 'tr' && getStyle('borderCollapse', this.content_elem) != 'collapse') opts.item_height += parseInt(getStyle('borderSpacing', this.content_elem)) || 0;\n\t\t\t\t\t\topts.block_height = opts.item_height * opts.rows_in_block;\n\t\t\t\t\t\topts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\n\t\t\t\t\t\topts.cluster_height = opts.blocks_in_cluster * opts.block_height;\n\t\t\t\t\t\treturn prev_item_height != opts.item_height;\n\t\t\t\t\t},\n\t\t\t\t\t// get current cluster number\n\t\t\t\t\tgetClusterNum: function getClusterNum() {\n\t\t\t\t\t\tthis.options.scroll_top = this.scroll_elem.scrollTop;\n\t\t\t\t\t\treturn Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\n\t\t\t\t\t},\n\t\t\t\t\t// generate empty row if no data provided\n\t\t\t\t\tgenerateEmptyRow: function generateEmptyRow() {\n\t\t\t\t\t\tvar opts = this.options;\n\t\t\t\t\t\tif (!opts.tag || !opts.show_no_data_row) return [];\n\t\t\t\t\t\tvar empty_row = document.createElement(opts.tag),\n\t\t\t\t\t\t    no_data_content = document.createTextNode(opts.no_data_text),\n\t\t\t\t\t\t    td;\n\t\t\t\t\t\tempty_row.className = opts.no_data_class;\n\t\t\t\t\t\tif (opts.tag == 'tr') {\n\t\t\t\t\t\t\ttd = document.createElement('td');\n\t\t\t\t\t\t\ttd.appendChild(no_data_content);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tempty_row.appendChild(td || no_data_content);\n\t\t\t\t\t\treturn [empty_row.outerHTML];\n\t\t\t\t\t},\n\t\t\t\t\t// generate cluster for current scroll position\n\t\t\t\t\tgenerate: function generate(rows, cluster_num) {\n\t\t\t\t\t\tvar opts = this.options,\n\t\t\t\t\t\t    rows_len = rows.length;\n\t\t\t\t\t\tif (rows_len < opts.rows_in_block) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttop_offset: 0,\n\t\t\t\t\t\t\t\tbottom_offset: 0,\n\t\t\t\t\t\t\t\trows_above: 0,\n\t\t\t\t\t\t\t\trows: rows_len ? rows : this.generateEmptyRow()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!opts.cluster_height) {\n\t\t\t\t\t\t\tthis.exploreEnvironment(rows);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\n\t\t\t\t\t\t    items_end = items_start + opts.rows_in_cluster,\n\t\t\t\t\t\t    top_offset = Math.max(items_start * opts.item_height, 0),\n\t\t\t\t\t\t    bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0),\n\t\t\t\t\t\t    this_cluster_rows = [],\n\t\t\t\t\t\t    rows_above = items_start;\n\t\t\t\t\t\tif (top_offset < 1) {\n\t\t\t\t\t\t\trows_above++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var i = items_start; i < items_end; i++) {\n\t\t\t\t\t\t\trows[i] && this_cluster_rows.push(rows[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttop_offset: top_offset,\n\t\t\t\t\t\t\tbottom_offset: bottom_offset,\n\t\t\t\t\t\t\trows_above: rows_above,\n\t\t\t\t\t\t\trows: this_cluster_rows\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\trenderExtraTag: function renderExtraTag(class_name, height) {\n\t\t\t\t\t\tvar tag = document.createElement(this.options.tag),\n\t\t\t\t\t\t    clusterize_prefix = 'clusterize-';\n\t\t\t\t\t\ttag.className = [clusterize_prefix + 'extra-row', clusterize_prefix + class_name].join(' ');\n\t\t\t\t\t\theight && (tag.style.height = height + 'px');\n\t\t\t\t\t\treturn tag.outerHTML;\n\t\t\t\t\t},\n\t\t\t\t\t// if necessary verify data changed and insert to DOM\n\t\t\t\t\tinsertToDOM: function insertToDOM(rows, cache) {\n\t\t\t\t\t\tvar data = this.generate(rows, this.getClusterNum()),\n\t\t\t\t\t\t    this_cluster_rows = data.rows.join(''),\n\t\t\t\t\t\t    this_cluster_content_changed = this.checkChanges('data', this_cluster_rows, cache),\n\t\t\t\t\t\t    only_bottom_offset_changed = this.checkChanges('bottom', data.bottom_offset, cache),\n\t\t\t\t\t\t    callbacks = this.options.callbacks,\n\t\t\t\t\t\t    layout = [];\n\n\t\t\t\t\t\tif (this_cluster_content_changed) {\n\t\t\t\t\t\t\tif (data.top_offset) {\n\t\t\t\t\t\t\t\tthis.options.keep_parity && layout.push(this.renderExtraTag('keep-parity'));\n\t\t\t\t\t\t\t\tlayout.push(this.renderExtraTag('top-space', data.top_offset));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlayout.push(this_cluster_rows);\n\t\t\t\t\t\t\tdata.bottom_offset && layout.push(this.renderExtraTag('bottom-space', data.bottom_offset));\n\t\t\t\t\t\t\tcallbacks.clusterWillChange && callbacks.clusterWillChange();\n\t\t\t\t\t\t\tthis.html(layout.join(''));\n\t\t\t\t\t\t\tthis.options.content_tag == 'ol' && this.content_elem.setAttribute('start', data.rows_above);\n\t\t\t\t\t\t\tcallbacks.clusterChanged && callbacks.clusterChanged();\n\t\t\t\t\t\t} else if (only_bottom_offset_changed) {\n\t\t\t\t\t\t\tthis.content_elem.lastChild.style.height = data.bottom_offset + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// unfortunately ie <= 9 does not allow to use innerHTML for table elements, so make a workaround\n\t\t\t\t\thtml: function html(data) {\n\t\t\t\t\t\tvar content_elem = this.content_elem;\n\t\t\t\t\t\tif (ie && ie <= 9 && this.options.tag == 'tr') {\n\t\t\t\t\t\t\tvar div = document.createElement('div'),\n\t\t\t\t\t\t\t    last;\n\t\t\t\t\t\t\tdiv.innerHTML = '<table><tbody>' + data + '</tbody></table>';\n\t\t\t\t\t\t\twhile (last = content_elem.lastChild) {\n\t\t\t\t\t\t\t\tcontent_elem.removeChild(last);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar rows_nodes = this.getChildNodes(div.firstChild.firstChild);\n\t\t\t\t\t\t\twhile (rows_nodes.length) {\n\t\t\t\t\t\t\t\tcontent_elem.appendChild(rows_nodes.shift());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_elem.innerHTML = data;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tgetChildNodes: function getChildNodes(tag) {\n\t\t\t\t\t\tvar child_nodes = tag.children,\n\t\t\t\t\t\t    nodes = [];\n\t\t\t\t\t\tfor (var i = 0, ii = child_nodes.length; i < ii; i++) {\n\t\t\t\t\t\t\tnodes.push(child_nodes[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t},\n\t\t\t\t\tcheckChanges: function checkChanges(type, value, cache) {\n\t\t\t\t\t\tvar changed = value != cache[type];\n\t\t\t\t\t\tcache[type] = value;\n\t\t\t\t\t\treturn changed;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// support functions\n\t\t\t\tfunction on(evt, element, fnc) {\n\t\t\t\t\treturn element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent(\"on\" + evt, fnc);\n\t\t\t\t}\n\t\t\t\tfunction off(evt, element, fnc) {\n\t\t\t\t\treturn element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent(\"on\" + evt, fnc);\n\t\t\t\t}\n\t\t\t\tfunction isArray(arr) {\n\t\t\t\t\treturn Object.prototype.toString.call(arr) === '[object Array]';\n\t\t\t\t}\n\t\t\t\tfunction getStyle(prop, elem) {\n\t\t\t\t\treturn window.getComputedStyle ? window.getComputedStyle(elem)[prop] : elem.currentStyle[prop];\n\t\t\t\t}\n\n\t\t\t\treturn Clusterize;\n\t\t\t});\n\n\t\t\t/***/\n\t\t},\n\t\t/* 3 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\t\tvalue: true\n\t\t\t});\n\n\t\t\tvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n\t\t\t\treturn typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n\t\t\t} : function (obj) {\n\t\t\t\treturn obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n\t\t\t};\n\n\t\t\t/**\n    * Example #1:\n    * =========================================================================\n    * <a id=\"mymail href=\"http://mymail.example.com\">My Mail</a>\n    *\n    * buildHTML('a', 'My Mail', {\n    *     id: 'mymail',\n    *     href: 'http://mymail.example.com'\n    * });\n    *\n    * Example #2:\n    * =========================================================================\n    * <input id=\"myinput\" type=\"text\" value=\"myvalue\" />\n    *\n    * buildHTML('input', {\n    *   id: 'myinput',\n    *   type: 'text',\n    *   value: 'myvalue'\n    * });\n    *\n    */\n\t\t\tvar buildHTML = function buildHTML(tag, html, attrs) {\n\t\t\t\tswitch (tag) {\n\t\t\t\t\tcase 'select':\n\t\t\t\t\t\tif ((typeof html === 'undefined' ? 'undefined' : _typeof(html)) === 'object') {\n\t\t\t\t\t\t\tvar options = html || {};\n\t\t\t\t\t\t\thtml = '';\n\t\t\t\t\t\t\tfor (var value in options) {\n\t\t\t\t\t\t\t\tif (!options.hasOwnProperty(value)) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\thtml += buildHTML('option', options[value] || '', { value: value });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ((typeof html === 'undefined' ? 'undefined' : _typeof(html)) === 'object') {\n\t\t\t\t\t\t\tattrs = html;\n\t\t\t\t\t\t\thtml = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar h = '<' + tag;\n\t\t\t\tfor (var attr in attrs) {\n\t\t\t\t\tif (!attrs.hasOwnProperty(attr)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof attrs[attr] !== 'undefined') {\n\t\t\t\t\t\th += ' ' + attr + '=\"' + quoteattr(attrs[attr]) + '\"';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\th += typeof html !== 'undefined' ? '>' + html + '</' + tag + '>' : '/>';\n\n\t\t\t\treturn h;\n\t\t\t};\n\n\t\t\tvar classNames = function classNames() {\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\n\t\t\t\tvar classNames = [];\n\t\t\t\targs.forEach(function (arg) {\n\t\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\t\tclassNames = classNames.concat(arg);\n\t\t\t\t\t} else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {\n\t\t\t\t\t\tObject.keys(arg).forEach(function (className) {\n\t\t\t\t\t\t\tvar ok = arg[className];\n\t\t\t\t\t\t\tif (!!ok) {\n\t\t\t\t\t\t\t\tclassNames.push(className);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclassNames.push(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn classNames.join(' ');\n\t\t\t};\n\n\t\t\t/**\n    * The quoteattr() function is used in a context, where the result will not be evaluated by javascript but must be interpreted by an XML or HTML parser, and it must absolutely avoid breaking the syntax of an element attribute.\n    */\n\t\t\tvar quoteattr = function quoteattr(s, preserveCR) {\n\t\t\t\tpreserveCR = preserveCR ? '&#13;' : '\\n';\n\t\t\t\treturn ('' + s). /* Forces the conversion to string. */\n\t\t\t\treplace(/&/g, '&amp;') /* This MUST be the 1st replacement. */\n\t\t\t\t.replace(/'/g, '&apos;') /* The 4 other predefined entities, required. */\n\t\t\t\t.replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')\n\t\t\t\t/*\n     * You may add other replacements here for HTML only\n     * (but it's not necessary).\n     * Or for XML, only if the named entities are defined in its DTD.\n     */\n\t\t\t\t.replace(/\\r\\n/g, preserveCR) /* Must be before the next replacement. */\n\t\t\t\t.replace(/[\\r\\n]/g, preserveCR);\n\t\t\t};\n\n\t\t\texports.buildHTML = buildHTML;\n\t\t\texports.classNames = classNames;\n\t\t\texports.quoteattr = quoteattr;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 4 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\t\tvalue: true\n\t\t\t});\n\n\t\t\tvar _slicedToArray = function () {\n\t\t\t\tfunction sliceIterator(arr, i) {\n\t\t\t\t\tvar _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n\t\t\t\t\t\tfor (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t\t\t\t\t\t\t_arr.push(_s.value);if (i && _arr.length === i) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_d = true;_e = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_n && _i[\"return\"]) _i[\"return\"]();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_d) throw _e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}return _arr;\n\t\t\t\t}return function (arr, i) {\n\t\t\t\t\tif (Array.isArray(arr)) {\n\t\t\t\t\t\treturn arr;\n\t\t\t\t\t} else if (Symbol.iterator in Object(arr)) {\n\t\t\t\t\t\treturn sliceIterator(arr, i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}();\n\n\t\t\tvar extend = function extend(target) {\n\t\t\t\tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\t\tsources[_key - 1] = arguments[_key];\n\t\t\t\t}\n\n\t\t\t\tsources.forEach(function (source) {\n\t\t\t\t\tfor (var key in source) {\n\t\t\t\t\t\tif (source.hasOwnProperty(key)) {\n\t\t\t\t\t\t\ttarget[key] = source[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn target;\n\t\t\t};\n\n\t\t\t// @param {object|array} nodes The tree nodes\n\t\t\t// @param {object} [options] The options object\n\t\t\t// @param {boolean} [options.openAllNodes] True to open all nodes. Defaults to false.\n\t\t\t// @param {array} [options.openNodes] An array that contains the ids of open nodes\n\t\t\t// @return {array}\n\t\t\tvar flatten = function flatten() {\n\t\t\t\tvar nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\t\t\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t\t\t\tnodes = [].concat(nodes);\n\n\t\t\t\tvar flatten = [];\n\t\t\t\tvar stack = [];\n\t\t\t\tvar pool = {\n\t\t\t\t\tlastChild: {}\n\t\t\t\t};\n\n\t\t\t\toptions.openAllNodes = !!options.openAllNodes;\n\t\t\t\toptions.openNodes = options.openNodes || [];\n\t\t\t\toptions.throwOnError = !!options.throwOnError;\n\n\t\t\t\t{\n\t\t\t\t\t// root node\n\t\t\t\t\tvar firstNode = nodes.length > 0 ? nodes[0] : null;\n\t\t\t\t\tvar parent = firstNode ? firstNode.parent : null;\n\t\t\t\t\tvar index = 0;\n\t\t\t\t\tvar root = parent || { // defaults\n\t\t\t\t\t\tlabel: '',\n\t\t\t\t\t\tparent: null,\n\t\t\t\t\t\tchildren: nodes,\n\t\t\t\t\t\tstate: {\n\t\t\t\t\t\t\tdepth: -1,\n\t\t\t\t\t\t\tpath: '',\n\t\t\t\t\t\t\ttotal: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (root === parent) {\n\t\t\t\t\t\tvar subtotal = root.state.total || 0;\n\n\t\t\t\t\t\t// Traversing up through its ancestors\n\t\t\t\t\t\tvar p = root;\n\t\t\t\t\t\twhile (p) {\n\t\t\t\t\t\t\tvar _p$state = p.state;\n\t\t\t\t\t\t\tvar path = _p$state.path;\n\t\t\t\t\t\t\tvar lastChild = _p$state.lastChild;\n\t\t\t\t\t\t\tvar _p$state$total = _p$state.total;\n\t\t\t\t\t\t\tvar total = _p$state$total === undefined ? 0 : _p$state$total;\n\n\t\t\t\t\t\t\t// Rebuild the lastChild pool\n\n\t\t\t\t\t\t\tif (path && lastChild) {\n\t\t\t\t\t\t\t\tpool.lastChild[path] = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Subtract the number 'subtotal' from the total of the root node and all its ancestors\n\t\t\t\t\t\t\tp.state.total = total - subtotal;\n\t\t\t\t\t\t\tif (p.state.total < 0) {\n\t\t\t\t\t\t\t\tif (options.throwOnError) {\n\t\t\t\t\t\t\t\t\tthrow new Error('The node might have been corrupted: id=' + JSON.stringify(p.id) + ', state=' + JSON.stringify(p.state));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconsole && console.log('Error: The node might have been corrupted: id=%s, label=%s, parent=%s, children=%s, state=%s', JSON.stringify(p.id), JSON.stringify(p.label), p.parent, p.children, JSON.stringify(p.state));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tp = p.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tstack.push([root, root.state.depth, index]);\n\t\t\t\t}\n\n\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\tvar _stack$pop = stack.pop();\n\n\t\t\t\t\tvar _stack$pop2 = _slicedToArray(_stack$pop, 3);\n\n\t\t\t\t\tvar current = _stack$pop2[0];\n\t\t\t\t\tvar depth = _stack$pop2[1];\n\t\t\t\t\tvar _index = _stack$pop2[2];\n\n\t\t\t\t\tvar _loop = function _loop() {\n\t\t\t\t\t\tvar node = current.children[_index];\n\t\t\t\t\t\tnode.parent = current;\n\t\t\t\t\t\tnode.children = node.children || [];\n\n\t\t\t\t\t\tvar path = current.state.path + '.' + _index;\n\t\t\t\t\t\tvar more = Object.keys(node.children).length > 0;\n\t\t\t\t\t\tvar open = more && function () {\n\t\t\t\t\t\t\tvar openAllNodes = options.openAllNodes;\n\t\t\t\t\t\t\tvar openNodes = options.openNodes;\n\n\t\t\t\t\t\t\tif (openAllNodes) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// determine by node object\n\t\t\t\t\t\t\tif (openNodes.indexOf(node) >= 0) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// determine by node id\n\t\t\t\t\t\t\tif (openNodes.indexOf(node.id) >= 0) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}();\n\t\t\t\t\t\tvar lastChild = _index === current.children.length - 1;\n\t\t\t\t\t\tvar prefixMask = function (prefix) {\n\t\t\t\t\t\t\tvar mask = '';\n\t\t\t\t\t\t\twhile (prefix.length > 0) {\n\t\t\t\t\t\t\t\tprefix = prefix.replace(/\\.\\d+$/, '');\n\t\t\t\t\t\t\t\tif (!prefix || pool.lastChild[prefix]) {\n\t\t\t\t\t\t\t\t\tmask = '0' + mask;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmask = '1' + mask;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mask;\n\t\t\t\t\t\t}(path);\n\n\t\t\t\t\t\tif (lastChild) {\n\t\t\t\t\t\t\tpool.lastChild[path] = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This allows you to put extra information to node.state\n\t\t\t\t\t\tnode.state = extend({}, node.state, {\n\t\t\t\t\t\t\tdepth: depth + 1,\n\t\t\t\t\t\t\tlastChild: lastChild,\n\t\t\t\t\t\t\tmore: more,\n\t\t\t\t\t\t\topen: open,\n\t\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\t\tprefixMask: prefixMask,\n\t\t\t\t\t\t\ttotal: 0\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Traversing up through its ancestors and update the total number of child nodes\n\t\t\t\t\t\t\tvar _p = node;\n\t\t\t\t\t\t\twhile (_p.parent !== null) {\n\t\t\t\t\t\t\t\t_p.parent.state.total++;\n\t\t\t\t\t\t\t\t_p = _p.parent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tflatten.push(node);\n\n\t\t\t\t\t\t++_index;\n\n\t\t\t\t\t\tif (more && !open) {\n\t\t\t\t\t\t\treturn 'continue';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (more) {\n\t\t\t\t\t\t\t// Push back parent node to the stack that will be able to continue\n\t\t\t\t\t\t\t// the next iteration once all the child nodes of the current node\n\t\t\t\t\t\t\t// have been completely explored.\n\t\t\t\t\t\t\tstack.push([current, depth, _index]);\n\n\t\t\t\t\t\t\t_index = 0;\n\t\t\t\t\t\t\tdepth = depth + 1;\n\t\t\t\t\t\t\tcurrent = node;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\twhile (_index < current.children.length) {\n\t\t\t\t\t\tvar _ret = _loop();\n\n\t\t\t\t\t\tif (_ret === 'continue') continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn flatten;\n\t\t\t};\n\n\t\t\texports.flatten = flatten;\n\n\t\t\t/***/\n\t\t}\n\t\t/******/])\n\t);\n});\n;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ../dist/infinite-tree.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../dist/infinite-tree.js?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }
/******/ ]);