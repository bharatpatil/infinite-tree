'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _clusterize = require('clusterize.js');

var _clusterize2 = _interopRequireDefault(_clusterize);

var _utils = require('./utils');

var _flattree = require('flattree');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var extend = function extend(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key];
            }
        }
    });

    return target;
};

var addEventListener = function addEventListener(target, type, listener) {
    if (target.attachEvent) {
        return target.attachEvent('on' + type, listener);
    } else {
        return target.addEventListener(type, listener, false);
    }
};

var removeEventListener = function removeEventListener(target, type, listener) {
    if (target.detachEvent) {
        return target.detachEvent('on' + type, listener);
    } else {
        return target.removeEventListener(type, listener, false);
    }
};

var stopPropagation = function stopPropagation(evt) {
    if (typeof evt.stopPropagation !== 'undefined') {
        evt.stopPropagation();
    } else {
        evt.cancelBubble = true;
    }
};

var generateRowsByNodes = function generateRowsByNodes() {
    var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    var rows = nodes.map(function (node) {
        var id = node.id;
        var label = node.label;
        var state = node.state;
        var depth = state.depth;
        var more = state.more;
        var open = state.open;
        var path = state.path;
        var children = state.children;
        var total = state.total;
        var _state$selected = state.selected;
        var selected = _state$selected === undefined ? false : _state$selected;


        var togglerContent = '';
        if (more && open) {
            togglerContent = '▼';
        }
        if (more && !open) {
            togglerContent = '►';
        }
        var toggler = (0, _utils.buildHTML)('a', togglerContent, {
            'class': function () {
                if (more && open) {
                    return (0, _utils.classNames)('tree-toggler');
                }
                if (more && !open) {
                    return (0, _utils.classNames)('tree-toggler', 'tree-closed');
                }
                return '';
            }()
        });
        var title = (0, _utils.buildHTML)('span', (0, _utils.quoteattr)(label), {
            'class': (0, _utils.classNames)('tree-title')
        });
        var treeNode = (0, _utils.buildHTML)('div', toggler + title, {
            'class': 'tree-node',
            'style': 'margin-left: ' + depth * 12 + 'px'
        });
        var treeItem = (0, _utils.buildHTML)('div', treeNode, {
            'aria-id': id,
            'aria-expanded': more && open,
            'aria-depth': depth,
            'aria-path': path,
            'aria-selected': selected,
            'aria-children': children ? Object.keys(children).length : 0,
            'aria-total': total,
            'class': (0, _utils.classNames)('tree-item', { 'tree-selected': selected })
        });

        return treeItem;
    });

    return rows;
};

var InfiniteTree = function (_events$EventEmitter) {
    _inherits(InfiniteTree, _events$EventEmitter);

    function InfiniteTree() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _classCallCheck(this, InfiniteTree);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(InfiniteTree).call(this));

        _this.options = {
            el: null,
            autoOpen: false
        };
        _this.state = {
            openNodes: [],
            selectedNode: null
        };
        _this.clusterize = null;
        _this.nodes = [];
        _this.rows = [];
        _this.contentElement = null;

        _this.contentListener = function (evt) {
            var target = evt.target;
            var currentTarget = evt.currentTarget;


            stopPropagation(evt);

            if (target !== currentTarget) {
                var itemTarget = target;
                var itemIndex = 0;

                while (itemTarget && itemTarget.parentElement !== currentTarget) {
                    itemTarget = itemTarget.parentElement;
                }

                {
                    // Get item's index
                    var p = itemTarget;
                    while (p.previousSibling) {
                        p = p.previousSibling;
                        ++itemIndex;
                    }
                }

                var nodeIndex = itemIndex;
                var node = _this.nodes[nodeIndex];
                var _this$eventHandler = _this.eventHandler;
                var openNode = _this$eventHandler.openNode;
                var closeNode = _this$eventHandler.closeNode;
                var selectNode = _this$eventHandler.selectNode;

                // Click on the toggler to open/close a tree node

                if (target.className.indexOf('tree-toggler') >= 0) {
                    if (_this.state.openNodes.indexOf(node) >= 0) {
                        // Close node
                        closeNode({ evt: evt, node: node, nodeIndex: nodeIndex });
                    } else {
                        openNode({ evt: evt, node: node, nodeIndex: nodeIndex });
                    }
                } else {
                    selectNode({ evt: evt, node: node, nodeIndex: nodeIndex });
                }

                _this.clusterize.update(_this.rows);
            }
        };

        _this.eventHandler = {
            closeNode: function closeNode(_ref) {
                var evt = _ref.evt;
                var node = _ref.node;
                var nodeIndex = _ref.nodeIndex;

                // Keep selected node unchanged if "node" is equal to "this.state.selectedNode"
                if (_this.state.selectedNode && _this.state.selectedNode !== node) {
                    var selectNode = _this.eventHandler.selectNode;

                    // Action:
                    //   close "node.0.0"
                    //
                    // Tree:
                    // [0] - node.0
                    // [1]  - node.0.0      => next selected node (index=1, total=2)
                    // [2]      node.0.0.0  => last selected node (index=2, total=0)
                    // [3]      node.0.0.1
                    // [4]    node.0.1

                    var selectedIndex = _this.nodes.indexOf(_this.state.selectedNode);
                    var rangeFrom = nodeIndex + 1;
                    var rangeTo = nodeIndex + node.state.total;

                    if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {
                        selectNode({ evt: evt, node: node, nodeIndex: nodeIndex });
                    }
                }

                node.state.open = false; // Set node.state.open to false
                var openNodes = _this.state.openNodes.filter(function (node) {
                    return node.state.more && node.state.open;
                });
                _this.state.openNodes = openNodes;

                var deleteCount = node.state.total;

                {
                    // Traversing up through ancestors to subtract node.state.total
                    var p = node;
                    while (p) {
                        p.state.total = p.state.total - deleteCount;
                        p = p.parent;
                    }
                }

                // Remove elements from an array
                _this.nodes.splice(nodeIndex + 1, deleteCount);
                _this.rows.splice(nodeIndex + 1, deleteCount);
                _this.rows[nodeIndex] = generateRowsByNodes([node])[0];
                _this.emit('tree.close', node);
            },
            openNode: function openNode(_ref2) {
                var evt = _ref2.evt;
                var node = _ref2.node;
                var nodeIndex = _ref2.nodeIndex;

                node.state.open = true; // Set node.state.open to true
                var openNodes = [node].concat(_this.state.openNodes); // the most recently used items first
                _this.state.openNodes = openNodes;

                var nodes = (0, _flattree.flatten)(node.children, { openNodes: _this.state.openNodes });
                var rows = generateRowsByNodes(nodes);

                // Insert an array inside another array
                _this.nodes.splice.apply(_this.nodes, [nodeIndex + 1, 0].concat(nodes));
                _this.rows.splice.apply(_this.rows, [nodeIndex + 1, 0].concat(rows));
                _this.rows[nodeIndex] = generateRowsByNodes([node])[0];
                _this.emit('tree.open', node);
            },
            selectNode: function selectNode(_ref3) {
                var evt = _ref3.evt;
                var node = _ref3.node;
                var nodeIndex = _ref3.nodeIndex;

                // select node
                if (_this.state.selectedNode !== node) {
                    node.state.selected = true;
                    _this.rows[nodeIndex] = generateRowsByNodes([node])[0];
                }

                // deselect node
                if (_this.state.selectedNode) {
                    var selectedNode = _this.state.selectedNode;
                    var selectedIndex = _this.nodes.indexOf(selectedNode);
                    selectedNode.state.selected = false;
                    _this.rows[selectedIndex] = generateRowsByNodes([selectedNode])[0];
                }

                if (_this.state.selectedNode !== node) {
                    _this.state.selectedNode = node;
                    _this.emit('tree.select', node);
                } else {
                    _this.state.selectedNode = null;
                    _this.emit('tree.select', null);
                }
            }
        };
        var _options$autoOpen = options.autoOpen;
        var autoOpen = _options$autoOpen === undefined ? false : _options$autoOpen;
        var _options$el = options.el;
        var el = _options$el === undefined ? null : _options$el;
        var _options$data = options.data;
        var data = _options$data === undefined ? null : _options$data;


        if (!el) {
            console.error('Failed to initialize infinite tree: el is not specified.');
            return _possibleConstructorReturn(_this);
        }

        // Assign options
        _this.options = extend({}, { autoOpen: autoOpen, el: el });

        _this.create();

        // Load tree data if it's provided
        if (data) {
            _this.loadData(data);
        }
        return _this;
    }

    _createClass(InfiniteTree, [{
        key: 'create',
        value: function create() {
            var infiniteTree = document.createElement('div');
            infiniteTree.className = (0, _utils.classNames)('infinite-tree');
            var infiniteTreeScroll = document.createElement('div');
            infiniteTreeScroll.className = (0, _utils.classNames)('infinite-tree-scroll');
            var infiniteTreeContent = document.createElement('div');
            infiniteTreeContent.className = (0, _utils.classNames)('infinite-tree-content');

            infiniteTreeScroll.appendChild(infiniteTreeContent);
            infiniteTree.appendChild(infiniteTreeScroll);
            this.options.el.appendChild(infiniteTree);

            this.clusterize = new _clusterize2.default({
                tag: 'div',
                rows: [],
                scrollElem: infiniteTreeScroll,
                contentElem: infiniteTreeContent,
                no_data_class: 'infinite-tree-no-data'
            });

            this.contentElement = infiniteTreeContent;
            addEventListener(this.contentElement, 'click', this.contentListener);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            removeEventListener(this.contentElement, 'click', this.contentListener);

            if (this.clusterize) {
                this.clusterize.clear();
                this.clusterize = null;
            }

            this.nodes = [];
            this.rows = [];
            this.state.openNodes = [];
            this.state.selectedNode = null;

            // Remove all child nodes
            while (this.contentElement.firstChild) {
                this.contentElement.removeChild(this.contentElement.firstChild);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clusterize.clear();
            this.nodes = [];
            this.rows = [];
            this.state.openNodes = [];
            this.state.selectedNode = null;
        }
    }, {
        key: 'handleCloseNode',
        value: function handleCloseNode(_ref4) {
            var evt = _ref4.evt;
            var node = _ref4.node;
            var nodeIndex = _ref4.nodeIndex;

            // Keep selected node unchanged if "node" is equal to "this.state.selectedNode"
            if (this.state.selectedNode && this.state.selectedNode !== node) {
                // Action:
                //   close "node.0.0"
                //
                // Tree:
                // [0] - node.0
                // [1]  - node.0.0      => next selected node (index=1, total=2)
                // [2]      node.0.0.0  => last selected node (index=2, total=0)
                // [3]      node.0.0.1
                // [4]    node.0.1
                var selectedIndex = this.nodes.indexOf(this.state.selectedNode);
                var rangeFrom = nodeIndex + 1;
                var rangeTo = nodeIndex + node.state.total;

                if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {
                    this.eventHandler.selectNode({ evt: evt, node: node, nodeIndex: nodeIndex });
                }
            }

            node.state.open = false; // Set node.state.open to false
            var openNodes = this.state.openNodes.filter(function (node) {
                return node.state.more && node.state.open;
            });
            this.state.openNodes = openNodes;

            var deleteCount = node.state.total;

            {
                // Traversing up through ancestors to subtract node.state.total
                var p = node;
                while (p) {
                    p.state.total = p.state.total - deleteCount;
                    p = p.parent;
                }
            }

            // Remove elements from an array
            this.nodes.splice(nodeIndex + 1, deleteCount);
            this.rows.splice(nodeIndex + 1, deleteCount);
            this.rows[nodeIndex] = generateRowsByNodes([node])[0];
            this.emit('tree.close', node);
        }
    }, {
        key: 'handleOpenNode',
        value: function handleOpenNode(_ref5) {
            var evt = _ref5.evt;
            var node = _ref5.node;
            var nodeIndex = _ref5.nodeIndex;

            node.state.open = true; // Set node.state.open to true
            var openNodes = [node].concat(this.state.openNodes); // the most recently used items first
            this.state.openNodes = openNodes;

            var nodes = (0, _flattree.flatten)(node.children, { openNodes: this.state.openNodes });
            var rows = generateRowsByNodes(nodes);

            // Insert an array inside another array
            this.nodes.splice.apply(this.nodes, [nodeIndex + 1, 0].concat(nodes));
            this.rows.splice.apply(this.rows, [nodeIndex + 1, 0].concat(rows));
            this.rows[nodeIndex] = generateRowsByNodes([node])[0];
            this.emit('tree.open', node);
        }
    }, {
        key: 'handleSelectNode',
        value: function handleSelectNode(_ref6) {
            var evt = _ref6.evt;
            var node = _ref6.node;
            var nodeIndex = _ref6.nodeIndex;

            // select node
            if (this.state.selectedNode !== node) {
                node.state.selected = true;
                this.rows[nodeIndex] = generateRowsByNodes([node])[0];
            }

            // deselect node
            if (this.state.selectedNode) {
                var selectedNode = this.state.selectedNode;
                var selectedIndex = this.nodes.indexOf(selectedNode);
                selectedNode.state.selected = false;
                this.rows[selectedIndex] = generateRowsByNodes([selectedNode])[0];
            }

            if (this.state.selectedNode !== node) {
                this.state.selectedNode = node;
                this.emit('tree.select', node);
            } else {
                this.state.selectedNode = null;
                this.emit('tree.select', null);
            }
        }
        // Add a new node after this existing node.
        // @param {object} newNode
        // @param {object} node

    }, {
        key: 'addNodeAfter',
        value: function addNodeAfter(newNode, node) {}
        // TODO

        // Add a new node before this existing node.
        // @param {object} newNode
        // @param {object} node

    }, {
        key: 'addNodeBefore',
        value: function addNodeBefore(newNode, node) {}
        // TODO

        // Add a new node as parent of this existing node.
        // @param {object} newNode
        // @param {object} node

    }, {
        key: 'addParentNode',
        value: function addParentNode(newNode, node) {}
        // TODO

        // Add a node to this parent node. If parentNode is empty, then the new node becomes a root node.
        // @param {object} newNode The new node
        // @param {object} parentNode The parent node

    }, {
        key: 'appendNode',
        value: function appendNode(newNode, parentNode) {}
        // TODO

        // Close this node. The node must have child nodes.
        // @param {object} node

    }, {
        key: 'closeNode',
        value: function closeNode(node) {}
        // TODO

        // Get a tree node by the unique node id. This assumes that you have given the nodes in the data a unique id.
        // @param {string|number} id The unique node id

    }, {
        key: 'getNodeById',
        value: function getNodeById(id) {}
        // TODO

        // Get the selected node. Returns the row data or null.

    }, {
        key: 'getSelectedNode',
        value: function getSelectedNode() {
            return this.state.selectedNode;
        }
        // Get the state of the tree.
        // @return {object} Returns an object that contains the ids of open nodes and selected nodes

    }, {
        key: 'getState',
        value: function getState() {}
        // TODO

        // Get the root node of the tree.

    }, {
        key: 'getTree',
        value: function getTree() {
            var tree = this.nodes.length > 0 ? this.nodes[0] : null;
            while (tree && tree.parent !== null) {
                tree = tree.parent;
            }
            return tree;
        }
        // Load data in the tree.
        // @param {object|array} data The data is a node object or array of nodes
        // @param {object} [options] The options object

    }, {
        key: 'loadData',
        value: function loadData() {
            var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var _options$autoOpen2 = options.autoOpen;
            var autoOpen = _options$autoOpen2 === undefined ? this.options.autoOpen : _options$autoOpen2;


            this.nodes = (0, _flattree.flatten)(data, { openAllNodes: autoOpen });

            var openNodes = this.nodes.filter(function (node) {
                return node.state.more && node.state.open;
            });
            this.state.openNodes = openNodes;
            this.state.selectedNode = null;

            this.rows = generateRowsByNodes(this.nodes);
            this.clusterize.update(this.rows);
        }
        // Open this node. The node must have child nodes.
        // @param {object} node

    }, {
        key: 'openNode',
        value: function openNode(node) {}
        // TODO

        // Remove node from the tree
        // @param {object} node

    }, {
        key: 'removeNode',
        value: function removeNode(node) {}
        // TODO

        // Scroll to this node.
        // @param {object} node

    }, {
        key: 'scrollToNode',
        value: function scrollToNode(node) {}
        // TODO

        // Select this node. You can deselect the current node by calling selectNode(null).
        // @param {object} node

    }, {
        key: 'selectNode',
        value: function selectNode(node) {}
        // TODO

        // Set the state of the tree. See getState for more information.
        // @param {object} state The state object
        // @param {string} [state.openNodes] The ids of open nodes
        // @param {string} [state.selectedNode] The id of selected node

    }, {
        key: 'setState',
        value: function setState() {
            var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        }
        // TODO

        // Open or close this node.

    }, {
        key: 'toggle',
        value: function toggle(node) {}
        // TODO

        // Get the tree data as string.

    }, {
        key: 'toString',
        value: function toString() {}
        // TODO

        // Update the title of a node. You can also update the data.
        // @param {object} node
        // @param {object} data The data object
        // @param {object} [data.label] The title of a node

    }, {
        key: 'updateNode',
        value: function updateNode(node, data) {
            // TODO
        }
    }]);

    return InfiniteTree;
}(_events2.default.EventEmitter);

module.exports = InfiniteTree;