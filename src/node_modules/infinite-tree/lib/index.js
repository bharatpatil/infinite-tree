'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _clusterize = require('clusterize.js');

var _clusterize2 = _interopRequireDefault(_clusterize);

var _flattree = require('flattree');

var _renderer = require('./renderer');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var extend = function extend(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key];
            }
        }
    });

    return target;
};

var addEventListener = function addEventListener(target, type, listener) {
    if (target.attachEvent) {
        return target.attachEvent('on' + type, listener);
    } else {
        return target.addEventListener(type, listener, false);
    }
};

var removeEventListener = function removeEventListener(target, type, listener) {
    if (target.detachEvent) {
        return target.detachEvent('on' + type, listener);
    } else {
        return target.removeEventListener(type, listener, false);
    }
};

var stopPropagation = function stopPropagation(evt) {
    if (typeof evt.stopPropagation !== 'undefined') {
        evt.stopPropagation();
    } else {
        evt.cancelBubble = true;
    }
};

var generateRows = function generateRows() {
    var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var rowRenderer = arguments.length <= 1 || arguments[1] === undefined ? _renderer.defaultRowRenderer : arguments[1];

    return nodes.map(function (node) {
        return rowRenderer(node);
    });
};

var InfiniteTree = function (_events$EventEmitter) {
    _inherits(InfiniteTree, _events$EventEmitter);

    function InfiniteTree() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _classCallCheck(this, InfiniteTree);

        // Assign options

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(InfiniteTree).call(this));

        _this.options = {
            autoOpen: false,
            el: null,
            rowRenderer: _renderer.defaultRowRenderer
        };
        _this.state = {
            openNodes: [],
            selectedNode: null
        };
        _this.clusterize = null;
        _this.nodebucket = {};
        _this.nodes = [];
        _this.rows = [];
        _this.contentElement = null;

        _this.contentListener = function (evt) {
            var target = evt.target;
            var currentTarget = evt.currentTarget;


            stopPropagation(evt);

            if (target !== currentTarget) {
                var itemTarget = target;

                while (itemTarget && itemTarget.parentElement !== currentTarget) {
                    itemTarget = itemTarget.parentElement;
                }

                var id = itemTarget.getAttribute('aria-id');
                var node = _this.getNodeById(id);

                // Click on the toggler to open/close a tree node
                if (target.className.indexOf('tree-toggler') >= 0) {
                    if (_this.state.openNodes.indexOf(node) >= 0) {
                        // Close node
                        _this.closeNode(node);
                    } else {
                        _this.openNode(node);
                    }
                } else {
                    _this.selectNode(node);
                }
            }
        };

        _this.options = extend({}, _this.options, options);

        if (!_this.options.el) {
            console.error('Failed to initialize infinite-tree: el is not specified.', options);
            return _possibleConstructorReturn(_this);
        }

        _this.create();

        // Load tree data if it's provided
        if (options.data) {
            _this.loadData(options.data);
        }
        return _this;
    }

    _createClass(InfiniteTree, [{
        key: 'create',
        value: function create() {
            var infiniteTree = document.createElement('div');
            infiniteTree.className = (0, _utils.classNames)('infinite-tree');
            var infiniteTreeScroll = document.createElement('div');
            infiniteTreeScroll.className = (0, _utils.classNames)('infinite-tree-scroll');
            var infiniteTreeContent = document.createElement('div');
            infiniteTreeContent.className = (0, _utils.classNames)('infinite-tree-content');

            infiniteTreeScroll.appendChild(infiniteTreeContent);
            infiniteTree.appendChild(infiniteTreeScroll);
            this.options.el.appendChild(infiniteTree);

            this.clusterize = new _clusterize2.default({
                tag: 'div',
                rows: [],
                scrollElem: infiniteTreeScroll,
                contentElem: infiniteTreeContent,
                no_data_class: 'infinite-tree-no-data'
            });

            this.contentElement = infiniteTreeContent;
            addEventListener(this.contentElement, 'click', this.contentListener);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            removeEventListener(this.contentElement, 'click', this.contentListener);

            if (this.clusterize) {
                this.clusterize.clear();
                this.clusterize = null;
            }

            this.nodes = [];
            this.rows = [];
            this.state.openNodes = [];
            this.state.selectedNode = null;

            // Remove all child nodes
            while (this.contentElement.firstChild) {
                this.contentElement.removeChild(this.contentElement.firstChild);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clusterize.clear();
            this.nodes = [];
            this.rows = [];
            this.state.openNodes = [];
            this.state.selectedNode = null;
        }
        // Updates list with new data

    }, {
        key: 'update',
        value: function update() {
            this.clusterize.update(this.rows);
        }
        // Add a new node after this existing node.
        // @param {object} newNode
        // @param {object} node

    }, {
        key: 'addNodeAfter',
        value: function addNodeAfter(newNode, node) {}
        // TODO

        // Add a new node before this existing node.
        // @param {object} newNode
        // @param {object} node

    }, {
        key: 'addNodeBefore',
        value: function addNodeBefore(newNode, node) {}
        // TODO

        // Add a new node as parent of this existing node.
        // @param {object} newNode
        // @param {object} node

    }, {
        key: 'addParentNode',
        value: function addParentNode(newNode, node) {}
        // TODO

        // Add a node to this parent node. If parentNode is empty, then the new node becomes a root node.
        // @param {object} newNode The new node
        // @param {object} parentNode The parent node

    }, {
        key: 'appendNode',
        value: function appendNode(newNode, parentNode) {}
        // TODO

        // Close this node. The node must have child nodes.
        // @param {object} node
        // @return {boolean} Returns true on success, false otherwise.

    }, {
        key: 'closeNode',
        value: function closeNode(node) {
            var rowRenderer = this.options.rowRenderer;

            // Retrieve node index

            var nodeIndex = this.nodes.indexOf(node);
            if (nodeIndex < 0) {
                throw new Error('Invalid node specified: node.id=' + JSON.stringify(node.id));
            }

            // Check if the closeNode action can be performed
            if (this.state.openNodes.indexOf(node) < 0) {
                return false;
            }

            // Keep selected node unchanged if "node" is equal to "this.state.selectedNode"
            if (this.state.selectedNode && this.state.selectedNode !== node) {
                // Action:
                //   close "node.0.0"
                //
                // Tree:
                // [0] - node.0
                // [1]  - node.0.0      => next selected node (index=1, total=2)
                // [2]      node.0.0.0  => last selected node (index=2, total=0)
                // [3]      node.0.0.1
                // [4]    node.0.1
                var selectedIndex = this.nodes.indexOf(this.state.selectedNode);
                var rangeFrom = nodeIndex + 1;
                var rangeTo = nodeIndex + node.state.total;

                if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {
                    this.selectNode(node);
                }
            }

            node.state.open = false; // Set node.state.open to false
            var openNodes = this.state.openNodes.filter(function (node) {
                return node.state.more && node.state.open;
            });
            this.state.openNodes = openNodes;

            var deleteCount = node.state.total;

            {
                // Traversing up through ancestors to subtract node.state.total
                var p = node;
                while (p) {
                    p.state.total = p.state.total - deleteCount;
                    p = p.parent;
                }
            }

            // Remove elements from an array
            this.nodes.splice(nodeIndex + 1, deleteCount);
            this.rows.splice(nodeIndex + 1, deleteCount);
            this.rows[nodeIndex] = rowRenderer(node);

            // Emit the 'tree.close' event
            this.emit('tree.close', node);

            // Updates list with new data
            this.update();

            return true;
        }
        // Get a tree node by the unique node id. This assumes that you have given the nodes in the data a unique id.
        // @param {string|number} id The unique node id. A null value will be returned if node.id not matched.

    }, {
        key: 'getNodeById',
        value: function getNodeById(id) {
            var node = (this.nodebucket[id] || [])[0];
            return node !== undefined ? node : null;
        }
        // Get the selected node. Returns the row data or null.

    }, {
        key: 'getSelectedNode',
        value: function getSelectedNode() {
            return this.state.selectedNode;
        }
        // Get the state of the tree.
        // @return {object} Returns an object that contains the ids of open nodes and selected nodes

    }, {
        key: 'getState',
        value: function getState() {}
        // TODO

        // Get the root node of the tree.

    }, {
        key: 'getTree',
        value: function getTree() {
            var tree = this.nodes.length > 0 ? this.nodes[0] : null;
            while (tree && tree.parent !== null) {
                tree = tree.parent;
            }
            return tree;
        }
        // Load data in the tree.
        // @param {object|array} data The data is a node object or array of nodes

    }, {
        key: 'loadData',
        value: function loadData() {
            var _this2 = this;

            var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
            var _options = this.options;
            var autoOpen = _options.autoOpen;
            var rowRenderer = _options.rowRenderer;


            this.nodes = (0, _flattree.flatten)(data, { openAllNodes: autoOpen });

            // Construct node bucket
            this.nodebucket = {};
            this.nodes.forEach(function (node) {
                if (node.id !== undefined) {
                    var nodebucket = _this2.nodebucket[node.id];
                    _this2.nodebucket[node.id] = nodebucket ? nodebucket.concat(node) : [node];
                }
            });

            var openNodes = this.nodes.filter(function (node) {
                return node.state.more && node.state.open;
            });
            this.state.openNodes = openNodes;
            this.state.selectedNode = null;

            this.rows = this.nodes.map(function (node) {
                return rowRenderer(node);
            });

            // Updates list with new data
            this.update();
        }
        // Open this node. The node must have child nodes.
        // @param {object} node
        // @return {boolean} Returns true on success, false otherwise.

    }, {
        key: 'openNode',
        value: function openNode(node) {
            var rowRenderer = this.options.rowRenderer;

            // Retrieve node index

            var nodeIndex = this.nodes.indexOf(node);
            if (nodeIndex < 0) {
                throw new Error('Invalid node specified: node.id=' + JSON.stringify(node.id));
            }

            // Check if the openNode action can be performed
            if (this.state.openNodes.indexOf(node) >= 0) {
                return false;
            }

            node.state.open = true; // Set node.state.open to true
            var openNodes = [node].concat(this.state.openNodes); // the most recently used items first
            this.state.openNodes = openNodes;

            var nodes = (0, _flattree.flatten)(node.children, { openNodes: this.state.openNodes });
            var rows = generateRows(nodes, rowRenderer);

            // Insert an array inside another array
            this.nodes.splice.apply(this.nodes, [nodeIndex + 1, 0].concat(nodes));
            this.rows.splice.apply(this.rows, [nodeIndex + 1, 0].concat(rows));
            this.rows[nodeIndex] = generateRows([node], rowRenderer)[0];

            // Emit the 'tree.open' event
            this.emit('tree.open', node);

            // Updates list with new data
            this.update();

            return true;
        }
        // Remove node from the tree
        // @param {object} node

    }, {
        key: 'removeNode',
        value: function removeNode(node) {}
        // TODO

        // Scroll to this node.
        // @param {object} node

    }, {
        key: 'scrollToNode',
        value: function scrollToNode(node) {}
        // TODO

        // Select this node. You can deselect the current node by calling selectNode(null) or selectNode().
        // @param {object} node
        // @return {boolean} Returns true on success, false otherwise.

    }, {
        key: 'selectNode',
        value: function selectNode() {
            var node = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
            var rowRenderer = this.options.rowRenderer;


            if (node === null) {
                // Deselect the current node
                if (this.state.selectedNode) {
                    var selectedNode = this.state.selectedNode;
                    var selectedIndex = this.nodes.indexOf(selectedNode);

                    selectedNode.state.selected = false;
                    this.rows[selectedIndex] = rowRenderer(selectedNode);
                    this.state.selectedNode = null;

                    // Emit the 'tree.select' event
                    this.emit('tree.select', null);

                    // Updates list with new data
                    this.update();

                    return true;
                }

                return false;
            }

            // Retrieve node index
            var nodeIndex = this.nodes.indexOf(node);
            if (nodeIndex < 0) {
                throw new Error('Invalid node specified: node.id=' + JSON.stringify(node.id));
            }

            // Select this node
            if (this.state.selectedNode !== node) {
                node.state.selected = true;
                this.rows[nodeIndex] = rowRenderer(node);
            }

            // Deselect the current node
            if (this.state.selectedNode) {
                var _selectedNode = this.state.selectedNode;
                var _selectedIndex = this.nodes.indexOf(_selectedNode);
                _selectedNode.state.selected = false;
                this.rows[_selectedIndex] = rowRenderer(_selectedNode);
            }

            if (this.state.selectedNode !== node) {
                this.state.selectedNode = node;

                // Emit the 'tree.select' event
                this.emit('tree.select', node);
            } else {
                this.state.selectedNode = null;

                // Emit the 'tree.select' event
                this.emit('tree.select', null);
            }

            // Updates list with new data
            this.update();

            return true;
        }
        // Set the state of the tree. See getState for more information.
        // @param {object} state The state object
        // @param {string} [state.openNodes] The ids of open nodes
        // @param {string} [state.selectedNode] The id of selected node

    }, {
        key: 'setState',
        value: function setState() {
            var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        }
        // TODO

        // Open or close this node.

    }, {
        key: 'toggle',
        value: function toggle(node) {}
        // TODO

        // Get the tree data as string.

    }, {
        key: 'toString',
        value: function toString() {}
        // TODO

        // Update the title of a node. You can also update the data.
        // @param {object} node
        // @param {object} data The data object
        // @param {object} [data.label] The title of a node

    }, {
        key: 'updateNode',
        value: function updateNode(node, data) {
            // TODO
        }
    }]);

    return InfiniteTree;
}(_events2.default.EventEmitter);

module.exports = InfiniteTree;