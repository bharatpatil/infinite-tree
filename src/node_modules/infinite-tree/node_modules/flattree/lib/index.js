'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var extend = function extend(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key];
            }
        }
    });

    return target;
};

// @param {object|array} nodes The tree nodes
// @param {object} [options] The options object
// @param {boolean} [options.openAllNodes] True to open all nodes. Defaults to false.
// @param {array} [options.openNodes] An array that contains the ids of open nodes
// @return {array}
var flatten = function flatten() {
    var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    nodes = [].concat(nodes);

    var flatten = [];
    var stack = [];
    var pool = {
        lastChild: {}
    };

    options.openAllNodes = !!options.openAllNodes;
    options.openNodes = options.openNodes || [];
    options.throwOnError = !!options.throwOnError;

    {
        // root node
        var firstNode = nodes.length > 0 ? nodes[0] : null;
        var parent = firstNode ? firstNode.parent : null;
        var index = 0;
        var root = parent || { // defaults
            label: '',
            parent: null,
            children: nodes,
            state: {
                depth: -1,
                path: '',
                total: 0
            }
        };

        if (root === parent) {
            var subtotal = root.state.total || 0;

            // Traversing up through its ancestors
            var p = root;
            while (p) {
                var _p$state = p.state;
                var path = _p$state.path;
                var lastChild = _p$state.lastChild;
                var _p$state$total = _p$state.total;
                var total = _p$state$total === undefined ? 0 : _p$state$total;

                // Rebuild the lastChild pool

                if (path && lastChild) {
                    pool.lastChild[path] = true;
                }

                // Subtract the number 'subtotal' from the total of the root node and all its ancestors
                p.state.total = total - subtotal;
                if (p.state.total < 0) {
                    if (options.throwOnError) {
                        throw new Error('The node might have been corrupted: id=' + JSON.stringify(p.id) + ', state=' + JSON.stringify(p.state));
                    } else {
                        console && console.log('Error: The node might have been corrupted: id=%s, label=%s, parent=%s, children=%s, state=%s', JSON.stringify(p.id), JSON.stringify(p.label), p.parent, p.children, JSON.stringify(p.state));
                    }
                }

                p = p.parent;
            }
        }

        stack.push([root, root.state.depth, index]);
    }

    while (stack.length > 0) {
        var _stack$pop = stack.pop();

        var _stack$pop2 = _slicedToArray(_stack$pop, 3);

        var current = _stack$pop2[0];
        var depth = _stack$pop2[1];
        var _index = _stack$pop2[2];

        var _loop = function _loop() {
            var node = current.children[_index];
            node.parent = current;
            node.children = node.children || [];

            var path = current.state.path + '.' + _index;
            var more = Object.keys(node.children).length > 0;
            var open = more && function () {
                var openAllNodes = options.openAllNodes;
                var openNodes = options.openNodes;

                if (openAllNodes) {
                    return true;
                }
                // determine by node object
                if (openNodes.indexOf(node) >= 0) {
                    return true;
                }
                // determine by node id
                if (openNodes.indexOf(node.id) >= 0) {
                    return true;
                }
                return false;
            }();
            var lastChild = _index === current.children.length - 1;
            var prefixMask = function (prefix) {
                var mask = '';
                while (prefix.length > 0) {
                    prefix = prefix.replace(/\.\d+$/, '');
                    if (!prefix || pool.lastChild[prefix]) {
                        mask = '0' + mask;
                    } else {
                        mask = '1' + mask;
                    }
                }
                return mask;
            }(path);

            if (lastChild) {
                pool.lastChild[path] = true;
            }

            // This allows you to put extra information to node.state
            node.state = extend({}, node.state, {
                depth: depth + 1,
                lastChild: lastChild,
                more: more,
                open: open,
                path: path,
                prefixMask: prefixMask,
                total: 0
            });

            {
                // Traversing up through its ancestors and update the total number of child nodes
                var _p = node;
                while (_p.parent !== null) {
                    _p.parent.state.total++;
                    _p = _p.parent;
                }
            }

            flatten.push(node);

            ++_index;

            if (more && !open) {
                return 'continue';
            }

            if (more) {
                // Push back parent node to the stack that will be able to continue
                // the next iteration once all the child nodes of the current node
                // have been completely explored.
                stack.push([current, depth, _index]);

                _index = 0;
                depth = depth + 1;
                current = node;
            }
        };

        while (_index < current.children.length) {
            var _ret = _loop();

            if (_ret === 'continue') continue;
        }
    }

    return flatten;
};

exports.flatten = flatten;